# 跨域

不支持跨域

```
cookie
LocalStorage
DOM元素也要同源策略iframe
ajax也不支持跨域
```

实现跨域的方式（9种）

```
jsonp 
postMessage
window.name
location.hash
document.domain
cors 后端设置允许请求头 'Access-Control-Allow-Origin'
websocket 
nginx
webpack（http-proxy） 代理 http serve 反响代理


```

# JSONP

> 只能发送get请求，不支持其他方式 
>
> 不安全 xss攻击，比如jsonp返回再次创建script标签的脚本

```js
利用浏览器script脚本的特性，也可以利用其他的标签，style也可以
通过拉取数据然后执行回调函数获取数据，即可。
function jsonp({ url, params, cb }) {
  return new Promise((resolve, reject) => {
    let srcipt = document.createElement('script')
    window[cb] = function(data) {
      resolve(data)
      document.body.removeChild(srcipt)
    }
    params = { ...params, cb }
    let arrs = []
    for (let key in params) {
      arrs.push(`${key}=${params[key]}`)
    }
    srcipt.src = `${url}?${arrs.join('&')}`
    document.body.appendChild(srcipt)
  })
}

jsonp({
  url: 'https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su',
  params: { wd: 'b' },
  cb: 'show'
}).then(data => {
  console.log(data, 'data')
})
```

# postMessage 、window.name、location.hash、document.domain

> 可以通过html页面的嵌套可以实现跨域处理

```
postMessage 
a页面
<iframe src="xx" id="iframe" onload="load()"></iframe>
function load(){
	let frame = doucument.getElementByid('#iframe')
	frame.contentWindow.postMessage('发送的内容',url)
	window.onmessage = function(e){
		console.log(e.data) // 接收到的参数
	}
}

b页面
window.onmessage = function(e){
	console.log(e.data) // 接收到的参数
	e.source.postMessage('发送的内容')
}


window.name 通过给name赋值。但是流程比较麻烦。


location.hash 通过把值放在hash上面，然后监听hanshchange事件

前提是数据互通是两个文件处在一级域名和二级域名的关系
document.domain 通过设置 document.domain = "一级域名"
```



# websocket

> 由于api具有全双工模式，不会受浏览器限制

```
高级api 不兼容老版本 需要使用socket.io做兼容

let socket = new WebSocket('ws:xxx')
socket.open = function(){
	socket.send("发送内容")
}
```



# nginx

> 服务器反向代理

```

```



# webpack（http-proxy）

> 前端项目服务器反向代理，通过http-serve

```

```

