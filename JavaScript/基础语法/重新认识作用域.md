# 重新认识作用域

下面讨论在非严格模式下。

作用域是一套规则

 **JavaScript 并不具有动态作用域。它只有词法作用域。**

主要区别:词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定 的（(this 也是!)）。词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。

```js
词法作用域。
function foo() { 
	console.log( a ); // 2
}
function bar() { 
	var a = 3;
	foo(); 
}
var a = 2; 
bar();

动态作用域
function foo2() { 
	console.log( a ); // 3 ，如果js是动态作用域的话那么a就是3，
}
function bar2() { 
	var a2 = 3;
	foo2(); 
}
var a2 = 2; 
bar2();

// 词法作用域。 主要的区别在于 foo 声明在window上， 看foo有没有参数传进来，没有的话就会在当前的作用域上往上找。这里找到了window上面的 a = 2

// 如果是 动态作用域 foo2声明在window上面就没有关系了，因为在 bar2 下面调用他，所以他会在 foo看有没有参数传进来，没有的话，在bar2里面找，那么他会找到 a = 3

```



> 词法作用域分为 LHS 查询（左侧查询），RHS查询（非左侧赋值）。
>
> LHS 和 RHS 的含义是“赋值操作的左侧或右侧”并不一定意味着就是“= 赋值操作符的左侧或右侧”。赋值操作还有其他几种形式，因此在概念上最 好将其理解为“赋值操作的目标是谁，使用的时候(LHS)，”以及“谁是赋值操作的源头，数据准备的时候(RHS)”。
>
> 不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式 地创建一个全局变量，该变量使用 LHS 引用的目标作为标识符。

```js
function foo(a) { 
	console.log( a ); // 2
}

foo( 2 );

// foo执行，首先去RHS引用。找到foo函数体并且执行。
// 接着形参需要被赋值 这时候他是一个变量需要 a = 2（隐式） ，先进行LHS查询
// 然后到console.log( a );  对RHS 查询，再对console.log函数进行RHS查询
```

看一下题。

```js
 var a = 0,
      b = 0
    function A(a) {
      A = function (b) {
        console.log(a + b++)
      }
      console.log(a++)
    }
    A(1)
    // 打印1 但是a已经变成了2 ,
    //  并且A函数的外层直接被替换
    //  function (b) {
    // console.log(a + b++)
    // }
    A(2) // 直接执行 上面的函数  2 + 2  = 4 ， b执行完后变成了 3

考点：作用域， a++ 和 ++a 区别 函数替换



var b = 10
    ;(function b() {
      // 'use strict'
      b = 20
      a = 10
      console.log(b, a)
    })()
 console.log( b,a) // 10,10
    // 解析： b在最外层作用域， 自执行函数是一块作用域b，b下面有一个变量声明 b=20。
    // 因为函数b已经被声明了，变量无法替换，只有函数可以替换，这里a=10 是可以被声明的。
    // 因为 在js 中如果赋值在当前找不到作用域，在外面作用域也找不到就会在外层var a = 10
    // 所以这里打印的是 函数b，10
```

