# 工程配置相关

## 类型检查指令

- `@ts-ignore`：禁用掉对下一行代码的类型检查，它本质是上 ignore 而不是 disable，也就意味着如果下一行代码并没有问题，那使用 ignore 反而就是一个错误了，这时候适合使用 `ts-expect-error`。
- ` @ts-expect-error`：它只有在**下一行代码真的存在错误时**才能被使用，否则它会给出一个错误
- `@ts-check`：检查JS文件，也可以使用JSDoc 的方式，进行不完全的类型检查。
- `@ts-nocheck`：TS 文件将不再接受类型检查



## 类型声明

> **通过额外的类型声明文件，在核心代码文件以外去提供对类型的进一步补全**。**为 TypeScript 类型检查与推导提供额外的类型信息。** 通过 declare 关键字进行编写`xx.d.ts`

npm包、或者你在window上面挂载对象，比如你通过script标签引入weixinSDK，就需要引入相关的Type或者自己写一套。

- npm 包可以使用 它们提供的type补全类型声明，React 就有 `@types/react`
  - @types/xxx：这些包其实是 .d.ts 这样的声明文件组成的
- 对于在 window对象上挂载对象的话，要不去网上找type包，要么就自己写。

### declare module

通常用于为没有提供类型定义的库进行类型的补全，以及为非代码文件提供基本类型定义。

#### 补全第三方模块类型

```ts
declare module 'pkg' {
  export const handler: () => boolean
}

// 使用
import foo from 'pkg';
const res = foo.handler();


declare module 'pkg' {
  const handler: () => boolean;
  export default handler;
}

// 使用
import bar from 'pkg2';
bar();
```

#### 补全非代码文件类型

> 图片、CSS、MD文件

```ts
declare module "*.png";
declare module "*.gif";
declare module "*.jpg";
declare module "*.jpeg";
declare module "*.svg";
declare module "*.css";
declare module "*.less";
declare module "*.scss";
declare module "*.sass";
declare module "*.styl";
declare module "*.md";
```

### 拓展全局变量Window

> 因为window是使用interface声明的，所以拓展它只需要继续新增属性即可

```ts
declare var window: Window & typeof globalThis;

interface Window {
  // ...
}

interface Window {
  hello: string;
}

window.hello
```

### namespace

> namespace的作用是隔离变量污染，模块化的思想。
>
> namespace 在ts文件中也会有使用，但是结合个人使用场景偏少不记录。

```ts
在 .d.ts 文件中进行定义
declare namespace WeixinJsSdk {

  /* namespace 内部内型  */
  type TypeTest = "TypeTest";


  interface InterfaceTset {
    name: string;
    age: number;
  }


  /* 导出去的方法 */
  function fn(options: TypeTest): void;

  /* 导出去的类 */
  class Foo {}
}

declare module "weixin-js-sdk" {
  export = WeixinJsSdk;
}

使用
import WeixinJsSdk from "weixin-js-sdk"
WeixinJsSdk.fn('TypeTest')
WeixinJsSdk.Foo
```

### tsconfig.json

[官网](https://www.typescriptlang.org/docs/handbook/compiler-options-in-msbuild.html#using-a-tsconfigjson)

#### 构建相关

##### 构建源码相关

##### **experimentalDecorators 与 emitDecoratorMetadata**

这两个选项都和装饰器有关，其中 experimentalDecorators 选项用于启用装饰器的 `@` 语法，而 emitDecoratorMetadata 配置则影响装饰器实际运行时的元数据相关逻辑，我们在装饰器一节中已经了解了此选项对实际编译代码的作用：

```tsx
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

__decorate([
    Prop(),
    __metadata("design:type", String) // 来自于 emitDecoratorMetadata 配置，其它 __metadata 方法同
], Foo.prototype, "prop", void 0);

__decorate([
    Method(),
    __param(0, Param()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", void 0)
], Foo.prototype, "handler", null);

Foo = __decorate([
    Cls(),
    __param(0, Param()),
    __metadata("design:paramtypes", [String])
], Foo);
```

##### **jsx、jsxFactory、jsxFragmentFactory 与 jsxImportSource**

- jsx：影响 JSX 组件的构建表现，以下为字符串参数

  - react：将 JSX 组件转换为对 `React.createElement` 调用，生成 `.js` 文件
  - preserve：原样保留 JSX 组件，生成 `.jsx` 文件，你可以接着让其他的编译器进行处理
  - react-native：类似于 preserve，但会生成 `.js` 文件
  - react-jsx/react-jsxdev： JSX 组件会被转换为对 `__jsx` 方法的调用与生成 `.js` 文件，此方法来自于 `react/jsx-runtime`

  ```tsx
  // react
  import React from 'react';
  export const helloWorld = () => React.createElement("h1", null, "Hello world");
  
  // preserve / react-native
  import React from 'react';
  export const helloWorld = () => <h1>Hello world</h1>;
  
  // react-jsx
  import { jsx as _jsx } from "react/jsx-runtime";
  import React from 'react';
  export const helloWorld = () => _jsx("h1", { children: "Hello world" });
   
  // react-jsxdev
  import { jsxDEV as _jsxDEV } from "react/jsx-dev-runtime";
  const _jsxFileName = "/home/runner/work/TypeScript-Website/TypeScript-Website/index.tsx";
  import React from 'react';
  export const helloWorld = () => _jsxDEV("h1", { children: "Hello world" }, void 0, false, { fileName: _jsxFileName, lineNumber: 9, columnNumber: 32 }, this);
  ```

- jsxFactory：影响负责最终处理转换完毕 JSX 组件的方法，默认即为 `React.createElement`
- jsxFragmentFactory：影响负责最终处理转换完毕 JSX 组件的方法，将 `<></>` 转换为 `React.Fragment`
- jsxImportSource：设置导入的源

##### target 与 lib、noLib

ESMAScript版本：es5、es6、es2018、es2021、es2022、esnext（基于目前的 TypeScript 版本所支持的最新版本

- target：配置构建代码使用的语法版本「参数为ESMAScript版本」
- lib：额外加载的库，它和target的版本有关系「参数为ESMAScript版本、DOM」
  - 如果target版本太低，则需要lib补充ESMAScript版本
  - 反之，则不需要补充

- noLib：不加载TypeScript 内置的类型定义，这样内置对象「String，Function，Object 等」没有类型定义，需要加载自己提供的

#### 构建解析相关

> 这部分配置主要控制源码解析，包括从何处开始收集要构建的文件，如何解析别名路径等等。

##### files、include 与 exclude

- files ：描述包含的所有文件，但不能使用 `src` 或者 `src/*` 这种方式，每个值都需要是完整的文件路径

  - ```json
    {
      "compilerOptions": {},
      "files": [
        "src/index.ts",
        "src/handler.ts"
      ]
    }
    ```

- include：描述包含的所有文件，可以使用正则

  - ```json
    {
      "include": ["src/**/*", "generated/*.ts", "internal/*"]
    }
    ```

- exclude：排除文件，可以使用正则，需要注意的是，**exclude 只能剔除已经被 include 包含的文件**

  - ```
    {
      "exclude": ["src/**/*", "generated/*.ts", "internal/*"]
    }
    ```

    

##### baseUrl

> 定义文件进行解析的根目录，推荐使用 `.`,或者 `./`，它们作用是一样的。

##### rootDir

> 项目文件的根目录,默认情况下它是项目内**包括**的所有 .ts 文件的最长公共路径，推荐使用 `.`,或者 `./`，它们作用是一样的。

##### rootDirs

> rootDirs 就是复数版本的 rootDir，它接收一组值，并且会将这些值均视为平级的根目录

```ts
PROJECT
├── src
│   ├── locales
│   │   ├── zh.locale.ts
│   │   ├── en.locale.ts
│   │   ├── jp.locale.ts
│   ├── index.ts
│── generated
│   ├── messages
│   │   ├── main.mapper.ts
│   │   ├── info.mapper.ts
├── tsconfig.json

"rootDirs": ["src/locales", "generated/messages"]
它只会告诉 TS 将这两个模块视为同一层级下（类型定义层面）。

构建产物
│── dist
│   ├── zh.locale.js
│   ├── en.locale.js
│   ├── jp.locale.js
│   ├── main.mapper.js
│   ├── info.mapper.js
```

##### types 与 typeRoots

- types ：只加载实际使用的类型定义包，默认值是默认加载node_modules下面所有的@types

  - ```tsx
    {
      "compilerOptions": {
        "types": ["node", "jest", "react"]
      }
    }
    在这种情况下，只有 @types/node、@types/jest 以及 @types/react 会被加载。
    即使其他 @types/ 包没有被包含，它们也仍然能拥有完整的类型，但其中的全局声明（如 process，expect，describe 等全局变量）将不会被包含，同时也无法再享受到基于类型的提示。
    
    这里解析可能有问题
    ```

- typeRoots：默认加载`node_modules/@types`

  - ```json
    {
      "compilerOptions": {
        "typeRoots": ["./node_modules/@types", "./node_modules/@team-types", "./typings"],
        "types": ["react"],
        "skipLibCheck": true
      }
    }
    
    以上配置会尝试加载 node_modules/@types/react 以及 ./node_modules/@team-types/react 、./typings/react 中的声明文件，注意我们需要使用相对于 baseUrl 的相对路径。
    
    加载多个声明文件可能会导致内部的声明冲突，所以你可能会需要 skipLibCheck 配置来禁用掉对加载的类型声明的检查。
    
    
    ```

##### moduleResolution

> 这一配置指定了模块的解析策略，可以配置为 node 或者 classic ，其中 node 为默认值，而 classic 主要作向后兼容用，基本不推荐使用。

node 模块解析，参考 `Commonjs` 规范

##### moduleSuffixes

此配置在 4.7 版本被引入，类似于 moduleResolution ，它同样影响对模块的解析策略，但仅影响模块的后缀名部分。如以下配置：

```json
{
    "compilerOptions": {
        "moduleSuffixes": [".ios", ".native", ""]
    }
}
```

此配置在解析文件时，会首先尝试查找 `foo.ios.ts`，然后是 `foo.native.ts`，最后才是 `foo.ts`（注意，需要最后的空字符串`""`配置）。很明显，这一配置主要是为了 React Native 配置中的多平台构建配置。但你可以用它在 Angular 项目中，确保所有文件都使用了一个额外的后缀名，如 `user.service.ts`、`user.module.ts` 等。

#### noResolve

默认情况下， TypeScript 会将你代码中导入的文件也解析为程序的一部分，包括 import 导入和三斜线指令的导入，你可以通过禁用这一配置来阻止这个解析过程。

需要注意的是，虽然导入过程被禁用了，但你仍然需要确保导入的模块是一个合法的模块。

```typescript
// 开启此配置后，这个指令指向的声明文件将不会被加载！
/// <reference path="./other.d.ts" />
```
