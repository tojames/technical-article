# 从输入 URL 到渲染页面

#### **第一步：URL 解析**

客户端

- 地址解析

![地址解析](../static/images/%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90.png)

协议：http 默认端口 21， https = tsl 默认端口 80 ，ftp 默认端口 443



#### **第二步：缓存检查**

**强缓存 Expires / Cache-Control**

```
Memory Cache、Disk Cache 都属于强缓存
浏览器对于强缓存的处理：根据第一次请求资源时返回的响应头来确定的
Expires：缓存过期时间，用来指定资源到期的时间（HTTP/1.0）
Cache-Control：cache-control: max-age=2592000第一次拿到资源后的2592000秒内（30天），再次发送请求，读取缓存中的信息（HTTP/1.1）
两者同时存在的话，Cache-Control优先级高于Expires
```

> 缓存位置：
>
> - Memory Cache : 内存缓存
>
> - Disk Cache：硬盘缓存
>
> 打开网页：查找 disk cache 中是否有匹配，如有则使用，如没有则发送网络请求
> 普通刷新 (F5)：因 TAB 没关闭，因此 memory cache 是可用的，会被优先使用，其次才是 disk cache
> 强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control: no-cache，服务器直接返回 200 和最新内容

```
三级缓存原理
	1、先查找内存，如果内存中存在，从内存中加载；
	2、如果内存中未查找到，选择硬盘获取，如果硬盘中有，从硬盘中加载；
	3、如果硬盘中未查找到，那就进行网络请求；
	4、加载到的资源缓存到硬盘和内存；

200 form memory cache
不访问服务器，一般已经加载过该资源且缓存在了内存当中，直接从内存中读取缓存。浏览器关闭后，数据将不存在（资源被释放掉了），再次打开相同的页面时，不会出现from memory cache，一般脚本、字体、图片会存在内存当中。

200 from disk cache
不访问服务器，已经在之前的某个时间加载过该资源，直接从硬盘中读取缓存，关闭浏览器后，数据依然存在，此资源不会随着该页面的关闭而释放掉下次打开仍然会是from disk cache，一般非脚本会存在内存当中，如css等。

304 Not Modified
访问服务器，发现数据没有更新，服务器返回此状态码。然后从缓存中读取数据。

200	资源大小数值	从服务器下载最新资源

参考：https://www.jianshu.com/p/8332da83955d
```

<img src="../static/images/强缓存.png" alt="强缓存" style="zoom:50%;" />

**协商缓存 Last-Modified / ETag**「总是和服务器协商」

```
Last-Modified「http 1.0」 ETag「http 1.1」
协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程

Last-Modified 表示本文件最后修改日期「可在服务器修改和本地修改，如打开操作即可」，浏览器会在request header加上If-Modified-Since（上次返回的Last-Modified的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来
```

<img src="../static/images/协商缓存.png" alt="协商缓存" style="zoom:50%;" />

#### **第三步：DNS 解析**

> 每一次 DNS 解析时间预计在 20~120 毫秒
>
> - 减少 DNS 请求次数
> - DNS 预获取（DNS Prefetch）
>
> <meta http-equiv="x-dns-prefetch-control" content="on">
> <link rel="dns-prefetch" href="//static.360buyimg.com"/>

- 递归查询
- 迭代查询

![DNS解析-递归查询](../static/images/DNS%E8%A7%A3%E6%9E%90-%E9%80%92%E5%BD%92%E6%9F%A5%E8%AF%A2.png)

#### **第四步：TCP 三次握手**

> UDP 是即时通信。
>
> - seq 序号，用来标识从 TCP 源端向目的端发送的字节流，发起方发送数据时对此进行标记
> - ack 确认序号： 表示期望下一次应该接受到的报文的第一个字节的序号，若ack = N则表示，到序号N-1为止的所有的数据都已经正确的收到了。只有 ACK 标志位为 1 时，确认序号字段才有效，ack=seq+1。建立连接后，所有传送的报文段都必须把ACK置为1。
>
> 
>
> - 标志位
>   - ACK：确认序号有效 ACK是一个对数据包的确认，当正确收到数据包后，接收端会发送一个ACk给发送端，里面会说明对那个数据包进行确认，每个数据包里都会有一个序列号，如果收到的数据包有误，或错序，还会申请重发，NAK是一个否定的回答，ACK是确定回答，这样保证数据的正确传输，这是TCP协议的传输机制，被称为面向连接的。
>   - RST：重置连接
>   - SYN：发起一个新连接，当两台计算机在TCP连接上进行会话时，连接一定会首先被初始化。完成这项任务的包叫作SYN。
>   - FIN：释放一个连接 带有该标志置位的数据包用来结束一个TCP回话，但对应端口仍处于开放状态，准备接收后续数据

**三次握手流程**

```

第一次握手客户端发送请求「新链接SYN，序号seq」链接给服务器。
	过程是SYN包初始化完成，准备好连接了SYN=1，并且发送了发送数据包的第一个字节的序号，seq=x。
第二次握手服务器处理完处理返回「新链接SYN=1，确认序号有效ACK=1，返回新的序号seq=y，确认序号ack=x+1」
	接受到合法的连接请求然后也进行初始化SYN=1，并且确认ACK=1，还有ack = x+1，期望下次握手能拿到x+1的序号
	seq发送包的第一个字节的序号
第三次握手客户端「确认序号有效ACK=1， 返回新的序号seq=x+1，确认序号ack=y+1」
	这时候SYN是0就忽略了，不用再初始化了，确认ACK=1 然后期望下次收到的是 ack=y+1，并且seq = x+1，发送给服务器，完成它的期望。
	
然后就可以传输数据，http1.1是长链接，断开链接后才需要重新建立连接通道。
TCP作为一种可靠传输控制协议，其核心思想：既要保证数据可靠传输，又要提高传输的效率！

如果是两次握手？
	服务端无法确认客户端是否收到了信息，从而无法进行下一步建立通道的操作。
如果是四次握手？
	服务端如果是第四次握手的话，就会存在没有什么需要确认的信息回去了，因为需要确认的序号都已经确认好了，无需多余的操作。
```

![三次握手](../static/images/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png)



#### **第五步：数据传输**

```
- HTTP报文
  - 请求报文
  - 响应报文
- 响应状态码
  - 200 OK
  - 202 Accepted ：服务器已接受请求，但尚未处理（异步）
  - 204 No Content：服务器成功处理了请求，但不需要返回任何实体内容
  - 206 Partial Content：服务器已经成功处理了部分 GET 请求（断点续传 Range/If-Range/Content-Range/Content-Type:”multipart/byteranges”/Content-Length….）
  - 301 Moved Permanently
  - 302 Move Temporarily
  - 304 Not Modified
  - 305 Use Proxy
  - 400 Bad Request : 请求参数有误
  - 401 Unauthorized：权限（Authorization）
  - 404 Not Found
  - 405 Method Not Allowed
  - 408 Request Timeout
  - 500 Internal Server Error
  - 503 Service Unavailable
  - 505 HTTP Version Not Supported
  - ……
```

#### **第六步：TCP 四次挥手**

> - 服务器端收到客户端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文
> - 但关闭连接时，当服务器端收到 FIN 报文时，很可能并不会立即关闭链接，所以只能先回复一个 ACK 报文，告诉客户端：”你发的 FIN 报文我收到了”，只有等到服务器端所有的报文都发送完了，我才能发送 FIN 报文，因此不能一起发送，故需要四步握手。
>
> Connection: keep-alive http1.0 需要设置，http1.1 默认就是长链接，一般页面关闭后就会关闭链接。

**为什么 TCP 需要四次挥手而不是 2 次挥手呢**

```
因为当客户端发送断开请求的时候，服务端需要马上回复客户端，但是服务端此时需要做一些比较费时的事情，所以先马上返回客户端‘好的，我正在处理后续的断开操作’，等处理完了，再去返回给客户端，接着客户端接收到了，回复一下服务端，就可以断开了

```



**四次挥手流程**

```
说明：当通信完成后，A和B都可以主动断开连接，例如，客户端A不主动断开连接，也不发送数据，B还等着接受，会占用服务器B的资源，B也可以主动断开连接。

  （1）A，B都处于ESTAB-LISHED建立连接状态。当A发送完数据后，想要断开连接，向B发送FIN=1（1代表请求断开连接），seq=u（这次发送的包，在我这所排的序号），发送后，A进入FIN-WAIT-1 终止等待1状态。

（2）当B收到A的请求后，回复ACK=1（确认收到），seq=v（这个包在我这，即在服务器B这排序为v，因为之前传输数据传输了很多包，这个排序不确定），ack=u+1（请求下一个发送的包为u+1，代表上一个包u已收到），当B发送后，进入CLOSE-WAIT关闭等待状态

（3）A收到B的回复后，进入FIN-WAIT-2终止等待2状态,因为B仅仅是回复了，我收到你的断开请求了，但是B没说是否同意断开，所以A继续等待。

（4）服务器B再次发送FIN=1（发送中断请求，即同意中断），ACK=1（确认收到），seq=w（这个包在我这，即在服务器B这排序为w，在请求关闭的同时，可能之前传送的包因网络问题，还在传输过程中，这中间服务器还会收到包，所以包排序不确定，有可能不是v+1，所以命名为w），ack=u+1（请求下一个发送的包为u+1，因为A已经进入终止等待状态，不会主动再发送包了，所以上次请求的包u+1,A没有发送，B这次继续发请求还是这个包），当B发送后进入LIST-ACK最后确认状态。

（5）当A收到B的中断请求后，发送回复，ACK=1（确认收到），seq=u+1（发送包u+1,这个包在我这排序为u+1，即上次B的回复中，请求下次发的包），ack=w+1（A会算出这个包在B那边的排序。上一个包为w，所以这个包为w+1）,发送完后A进入TIME-WAIT时间等待状态，因为网络中可能还有数据在传输，所以A要等待一段时间，确认这些数据发送成功。

（6）当B收到A的确认后，进入CLOSED关闭状态，断开与A连接，然后会迅速进入LISTEN收听状态，继续接受下一个客户端的请求连接。当A等待2MSL（TCP报文段在网络中的最大生存时间,RFC 1122标准的建议值是2min），进入CLOSED关闭状态，断开与服务器B连接。
```



![四次挥手](../static/images/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png)

#### **第七步：页面渲染**

参考：https://juejin.cn/post/6844903565610188807

**CRP（Critical Rendering Path）关键渲染路径**

> 关键渲染路径是指浏览器从最初接收请求来的HTML、CSS、javascript等资源，然后解析、构建树、渲染布局、绘制，最后呈现给客户能看到的界面这整个过程。

浏览器渲染过程：

```
1.解析HTML生成DOM树。
2.解析CSS生成CSSOM规则树。
3.将DOM树与CSSOM规则树合并在一起生成渲染树。
4.遍历渲染树开始布局，计算每个节点的位置大小信息。
5.将渲染树每个节点绘制到屏幕。
```

##### 7.1.构建DOM树

当浏览器接收到服务器响应来的HTML文档后，会遍历文档节点，生成DOM树。

需要注意的是，DOM树的生成过程中可能会被CSS和JS的加载执行阻塞。渲染阻塞问题下文会讲。

##### 7.2.构建CSSOM规则树

浏览器解析CSS文件并生成CSS规则树，每个CSS文件都被分析成一个StyleSheet对象，每个对象都包含CSS规则。CSS规则对象包含对应于CSS语法的选择器和声明对象以及其他对象。

**渲染阻塞**

当浏览器遇到一个 script 标记时，DOM 构建将暂停，直至脚本完成执行，然后继续构建DOM。每次去执行JavaScript脚本都会严重地阻塞DOM树的构建，如果JavaScript脚本还操作了CSSOM，而正好这个CSSOM还没有下载和构建，浏览器甚至会延迟脚本执行和构建DOM，直至完成其CSSOM的下载和构建。

所以，script 标签的位置很重要。实际使用时，可以遵循下面两个原则：

CSS 优先：引入顺序上，CSS 资源先于 JavaScript 资源。
 JS置后：我们通常把JS代码放到页面底部，且JavaScript 应尽量少影响 DOM 的构建。

当解析html的时候，会把新来的元素插入dom树里面，同时去查找css，然后把对应的样式规则应用到元素上，查找样式表是按照从右到左的顺序去匹配的。

例如： div p {font-size: 16px}，会先寻找所有p标签并判断它的父标签是否为div之后才会决定要不要采用这个样式进行渲染）。
 所以，我们平时写CSS时，尽量用id和class，千万不要过渡层叠。

##### 7.3.构建渲染树

通过DOM树和CSS规则树我们便可以构建渲染树。浏览器会先从DOM树的根节点开始遍历每个可见节点。对每个可见节点，找到其适配的CSS样式规则并应用。

渲染树构建完成后，每个节点都是可见节点并且都含有其内容和对应规则的样式。这也是渲染树与DOM树的最大区别所在。渲染树是用于显示，那些不可见的元素当然就不会在这棵树中出现了，譬如。除此之外，display等于none的也不会被显示在这棵树里头，但是visibility等于hidden的元素是会显示在这棵树里头的。

##### 7.4.渲染树布局

布局阶段会从渲染树的根节点开始遍历，然后确定每个节点对象在页面上的确切大小与位置，布局阶段的输出是一个盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小。

##### 7.5.渲染树绘制

在绘制阶段，遍历渲染树，调用渲染器的paint()方法在屏幕上显示其内容。渲染树的绘制工作是由浏览器的UI后端组件完成的。

**reflow与repaint：**

根据渲染树布局，计算CSS样式，即每个节点在页面中的大小和位置等几何信息。HTML默认是流式布局的，CSS和js会打破这种布局，改变DOM的外观样式以及大小和位置。这时就要提到两个重要概念：replaint和reflow。
 replaint：屏幕的一部分重画，不影响整体布局，比如某个CSS的背景色变了，但元素的几何尺寸和位置不变。
 reflow： 意味着元件的几何尺寸变了，我们需要重新验证并计算渲染树。是渲染树的一部分或全部发生了变化。这就是Reflow，或是Layout。
 所以我们应该尽量减少reflow和replaint，我想这也是为什么现在很少有用table布局的原因之一。

display:none 会触发 reflow，visibility: hidden属性并不算是不可见属性，它的语义是隐藏元素，但元素仍然占据着布局空间，它会被渲染成一个空框，所以visibility:hidden 只会触发 repaint，因为没有发生位置变化。

有些情况下，比如修改了元素的样式，浏览器并不会立刻 reflow 或 repaint 一次，而是会把这样的操作积攒一批，然后做一次 reflow，这又叫异步 reflow 或增量异步 reflow。
 有些情况下，比如 resize 窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。



如果在body中间插入一段script，执行一个循环特别大的脚本，页面表现是什么样的？

页面会堵塞，无响应知道脚本执行完毕，这种体验太差了。

我们应该考虑这种代码应该重构，具体情况就有很多考虑的方式了。

脚本使用defer/async，如果脚本必须提前执行，那代码是不是改优化。

