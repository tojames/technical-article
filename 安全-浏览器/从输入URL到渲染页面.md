# 从输入 URL 到渲染页面

本文全文吹牛逼。

**CRP（Critical Rendering Path）关键渲染路径**

#### 客户端

**第一步：URL 解析**

- 地址解析

![地址解析](../static/images/%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90.png)

协议：http 默认端口 21， https = tsl 默认端口 80 ，ftp 默认端口 443



**第二步：缓存检查**

**强缓存 Expires / Cache-Control**

```
Memory Cache、Disk Cache 都属于强缓存
浏览器对于强缓存的处理：根据第一次请求资源时返回的响应头来确定的
Expires：缓存过期时间，用来指定资源到期的时间（HTTP/1.0）
Cache-Control：cache-control: max-age=2592000第一次拿到资源后的2592000秒内（30天），再次发送请求，读取缓存中的信息（HTTP/1.1）
两者同时存在的话，Cache-Control优先级高于Expires
```

> 缓存位置：
>
> - Memory Cache : 内存缓存
>
> - Disk Cache：硬盘缓存
>
> 打开网页：查找 disk cache 中是否有匹配，如有则使用，如没有则发送网络请求
> 普通刷新 (F5)：因 TAB 没关闭，因此 memory cache 是可用的，会被优先使用，其次才是 disk cache
> 强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control: no-cache，服务器直接返回 200 和最新内容

```
三级缓存原理
	1、先查找内存，如果内存中存在，从内存中加载；
	2、如果内存中未查找到，选择硬盘获取，如果硬盘中有，从硬盘中加载；
	3、如果硬盘中未查找到，那就进行网络请求；
	4、加载到的资源缓存到硬盘和内存；

200 form memory cache
不访问服务器，一般已经加载过该资源且缓存在了内存当中，直接从内存中读取缓存。浏览器关闭后，数据将不存在（资源被释放掉了），再次打开相同的页面时，不会出现from memory cache，一般脚本、字体、图片会存在内存当中。

200 from disk cache
不访问服务器，已经在之前的某个时间加载过该资源，直接从硬盘中读取缓存，关闭浏览器后，数据依然存在，此资源不会随着该页面的关闭而释放掉下次打开仍然会是from disk cache，一般非脚本会存在内存当中，如css等。

304 Not Modified
访问服务器，发现数据没有更新，服务器返回此状态码。然后从缓存中读取数据。

200	资源大小数值	从服务器下载最新资源

参考：https://www.jianshu.com/p/8332da83955d
```

<img src="../static/images/强缓存.png" alt="强缓存" style="zoom:50%;" />

**协商缓存 Last-Modified / ETag**「总是和服务器协商」

```
Last-Modified「http 1.0」 ETag「http 1.1」
协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程

Last-Modified 表示本文件最后修改日期「可在服务器修改和本地修改，如打开操作即可」，浏览器会在request header加上If-Modified-Since（上次返回的Last-Modified的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来
```

<img src="../static/images/协商缓存.png" alt="协商缓存" style="zoom:50%;" />

**第三步：DNS 解析**

> 每一次 DNS 解析时间预计在 20~120 毫秒
>
> - 减少 DNS 请求次数
> - DNS 预获取（DNS Prefetch）
>
> <meta http-equiv="x-dns-prefetch-control" content="on">
> <link rel="dns-prefetch" href="//static.360buyimg.com"/>

- 递归查询
- 迭代查询

![DNS解析-递归查询](../static/images/DNS%E8%A7%A3%E6%9E%90-%E9%80%92%E5%BD%92%E6%9F%A5%E8%AF%A2.png)

**第四步：TCP 三次握手**

> UDP 是即时通信。
>
> - seq 序号，用来标识从 TCP 源端向目的端发送的字节流，发起方发送数据时对此进行标记
> - ack 确认序号： 表示期望下一次应该接受到的报文的第一个字节的序号，若ack = N则表示，到序号N-1为止的所有的数据都已经正确的收到了。只有 ACK 标志位为 1 时，确认序号字段才有效，ack=seq+1。建立连接后，所有传送的报文段都必须把ACK置为1。
>
> 
>
> - 标志位
>   - ACK：确认序号有效 ACK是一个对数据包的确认，当正确收到数据包后，接收端会发送一个ACk给发送端，里面会说明对那个数据包进行确认，每个数据包里都会有一个序列号，如果收到的数据包有误，或错序，还会申请重发，NAK是一个否定的回答，ACK是确定回答，这样保证数据的正确传输，这是TCP协议的传输机制，被称为面向连接的。
>   - RST：重置连接
>   - SYN：发起一个新连接，当两台计算机在TCP连接上进行会话时，连接一定会首先被初始化。完成这项任务的包叫作SYN。
>   - FIN：释放一个连接 带有该标志置位的数据包用来结束一个TCP回话，但对应端口仍处于开放状态，准备接收后续数据

**三次握手流程**

```

第一次握手客户端发送请求「新链接SYN，序号seq」链接给服务器。
	过程是SYN包初始化完成，准备好连接了SYN=1，并且发送了发送数据包的第一个字节的序号，seq=x。
第二次握手服务器处理完处理返回「新链接SYN=1，确认序号有效ACK=1，返回新的序号seq=y，确认序号ack=x+1」
	接受到合法的连接请求然后也进行初始化SYN=1，并且确认ACK=1，还有ack = x+1，期望下次握手能拿到x+1的序号
	seq发送包的第一个字节的序号
第三次握手客户端「确认序号有效ACK=1， 返回新的序号seq=x+1，确认序号ack=y+1」
	这时候SYN是0就忽略了，不用再初始化了，确认ACK=1 然后期望下次收到的是 ack=y+1，并且seq = x+1，发送给服务器，完成它的期望。
	
然后就可以传输数据，http1.1是长链接，断开链接后才需要重新建立连接通道。
TCP作为一种可靠传输控制协议，其核心思想：既要保证数据可靠传输，又要提高传输的效率！

如果是两次握手？
	服务端无法确认客户端是否收到了信息，从而无法进行下一步建立通道的操作。
如果是四次握手？
	服务端如果是第四次握手的话，就会存在没有什么需要确认的信息回去了，因为需要确认的序号都已经确认好了，无需多余的操作。
```

![三次握手](../static/images/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png)



**第五步：数据传输**

```
- HTTP报文
  - 请求报文
  - 响应报文
- 响应状态码
  - 200 OK
  - 202 Accepted ：服务器已接受请求，但尚未处理（异步）
  - 204 No Content：服务器成功处理了请求，但不需要返回任何实体内容
  - 206 Partial Content：服务器已经成功处理了部分 GET 请求（断点续传 Range/If-Range/Content-Range/Content-Type:”multipart/byteranges”/Content-Length….）
  - 301 Moved Permanently
  - 302 Move Temporarily
  - 304 Not Modified
  - 305 Use Proxy
  - 400 Bad Request : 请求参数有误
  - 401 Unauthorized：权限（Authorization）
  - 404 Not Found
  - 405 Method Not Allowed
  - 408 Request Timeout
  - 500 Internal Server Error
  - 503 Service Unavailable
  - 505 HTTP Version Not Supported
  - ……
```

**第六步：TCP 四次挥手**

> - 服务器端收到客户端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文
> - 但关闭连接时，当服务器端收到 FIN 报文时，很可能并不会立即关闭链接，所以只能先回复一个 ACK 报文，告诉客户端：”你发的 FIN 报文我收到了”，只有等到服务器端所有的报文都发送完了，我才能发送 FIN 报文，因此不能一起发送，故需要四步握手。
>
> Connection: keep-alive http1.0 需要设置，http1.1 默认就是长链接，一般页面关闭后就会关闭链接。

**为什么 TCP 需要四次挥手而不是 2 次挥手呢**

```
因为当客户端发送断开请求的时候，服务端需要马上回复客户端，但是服务端此时需要做一些比较费时的事情，所以先马上返回客户端‘好的，我正在处理后续的断开操作’，等处理完了，再去返回给客户端，接着客户端接收到了，回复一下服务端，就可以断开了

```



**四次挥手流程**

```
说明：当通信完成后，A和B都可以主动断开连接，例如，客户端A不主动断开连接，也不发送数据，B还等着接受，会占用服务器B的资源，B也可以主动断开连接。

  （1）A，B都处于ESTAB-LISHED建立连接状态。当A发送完数据后，想要断开连接，向B发送FIN=1（1代表请求断开连接），seq=u（这次发送的包，在我这所排的序号），发送后，A进入FIN-WAIT-1 终止等待1状态。

（2）当B收到A的请求后，回复ACK=1（确认收到），seq=v（这个包在我这，即在服务器B这排序为v，因为之前传输数据传输了很多包，这个排序不确定），ack=u+1（请求下一个发送的包为u+1，代表上一个包u已收到），当B发送后，进入CLOSE-WAIT关闭等待状态

（3）A收到B的回复后，进入FIN-WAIT-2终止等待2状态,因为B仅仅是回复了，我收到你的断开请求了，但是B没说是否同意断开，所以A继续等待。

（4）服务器B再次发送FIN=1（发送中断请求，即同意中断），ACK=1（确认收到），seq=w（这个包在我这，即在服务器B这排序为w，在请求关闭的同时，可能之前传送的包因网络问题，还在传输过程中，这中间服务器还会收到包，所以包排序不确定，有可能不是v+1，所以命名为w），ack=u+1（请求下一个发送的包为u+1，因为A已经进入终止等待状态，不会主动再发送包了，所以上次请求的包u+1,A没有发送，B这次继续发请求还是这个包），当B发送后进入LIST-ACK最后确认状态。

（5）当A收到B的中断请求后，发送回复，ACK=1（确认收到），seq=u+1（发送包u+1,这个包在我这排序为u+1，即上次B的回复中，请求下次发的包），ack=w+1（A会算出这个包在B那边的排序。上一个包为w，所以这个包为w+1）,发送完后A进入TIME-WAIT时间等待状态，因为网络中可能还有数据在传输，所以A要等待一段时间，确认这些数据发送成功。

（6）当B收到A的确认后，进入CLOSED关闭状态，断开与A连接，然后会迅速进入LISTEN收听状态，继续接受下一个客户端的请求连接。当A等待2MSL（TCP报文段在网络中的最大生存时间,RFC 1122标准的建议值是2min），进入CLOSED关闭状态，断开与服务器B连接。
```



![四次挥手](../static/images/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png)

**第七步：页面渲染**

```
/*
 *     1.利用缓存
 *       + 对于静态资源文件实现强缓存和协商缓存（扩展：文件有更新，如何保证及时刷新？）
 *       + 对于不经常更新的接口数据采用本地存储做数据缓存（扩展：cookie / localStorage / vuex|redux 区别？）
 *     2.DNS优化
 *       + 分服务器部署，增加HTTP并发性（导致DNS解析变慢）
 *       + DNS Prefetch
 *     3.TCP的三次握手和四次挥手
 *       + Connection:keep-alive
 *     4.数据传输
 *       + 减少数据传输的大小
 *         + 内容或者数据压缩（webpack等）
 *         + 服务器端一定要开启GZIP压缩（一般能压缩60%左右）
 *         + 大批量数据分批次请求（例如：下拉刷新或者分页，保证首次加载请求数据少）
 *       + 减少HTTP请求的次数
 *         + 资源文件合并处理
 *         + 字体图标
 *         + 雪碧图 CSS-Sprit
 *         + 图片的BASE64
 *       + ......
 *     5.CDN服务器“地域分布式”
 *     6.采用HTTP2.0
 * ==============
 * 网络优化是前端性能优化的中的重点内容，因为大部分的消耗都发生在网络层，尤其是第一次页面加载，如何减少等待时间很重要“减少白屏的效果和时间”
 *     + LOADDING 人性化体验
 *     + 骨架屏：客户端骨屏 + 服务器骨架屏
 *     + 图片延迟加载
```
