#### 1.双向绑定和 Vuex 是否冲突?

```js

当在严格模式中使用 Vuex 时，在属于 Vuex 的 state 上使用 v-model 会比较棘手：

<input v-model="obj.message">
假设这里的 obj 是在计算属性中返回的一个属于 Vuex store 的对象，在用户输入时，v-model 会试图直接修改 obj.message。在严格模式中，由于这个修改不是在 mutation 函数中执行的, 这里会抛出一个错误。

用“Vuex 的思维”去解决这个问题的方法是：给 <input> 中绑定 value，然后侦听 input 或者 change 事件，在事件回调中调用一个方法:

<input :value="message" @input="updateMessage">

computed: {
  ...mapState({
    message: state => state.obj.message
  })
},
methods: {
  updateMessage (e) {
    this.$store.commit('updateMessage', e.target.value)
  }
}
mutations: {
  updateMessage (state, message) {
    state.obj.message = message
  }
}


或者
<input v-model="message" />
computed: {
    message: {
        set (value) {
            this.$store.dispatch('updateMessage', value);
        },
        get () {
            return this.$store.state.obj.message
        }
    }
}
mutations: {
    UPDATE_MESSAGE (state, v) {
        state.obj.message = v;
    }
}
actions: {
    update_message ({ commit }, v) {
        commit('UPDATE_MESSAGE', v);
    }
}
```



#### 2.Vue的执行流程?

```
先对选项对象初始化，通过Object.defineProperty建立一套响应式系统，然后将模板先解析成AST对象 再解析成render函数，然后使用render函数生成vnode，在渲染前，对vnode进行diff操作，最后进行必要的渲染


AST对象：
{
   attrs: [{name: "id", value: ""app"", dynamic: undefined, start: 5, end: 13}],
   attrsList: [{name: "id", value: "app", start: 5, end: 13}],
   attrsMap: {id: "app"},
   children: [{
        attrsList: [],
        attrsMap: {},
        children: [],
        end: 33,
        parent: {type: 1, tag: "div", ...},
        plain: true,
        pre: undefined,
        rawAttrsMap:{},
        start: 19
        tag: "p",
        type: 1
   }],
   end: 263,
   parent: undefined,
   plain: false,
   rawAttrsMap:{id: {name: "id", value: "app", start: 5, end: 13}},
   start: 0
   tag: "div",
   type: 1
}

render 函数
with(this){
    return _c('div', {attrs:{"id":"app"}}, [_c('p', [_v(_s(msg))])])
}

虚拟dom {
    tag: "div",
    children: [{tag: "p", ...}],
    data: {attrs: {id: "app"}}
    elm: DOM节点（div#app）,
    parent: undefined,
    context: Vue实例,
    ...
}
```



#### 3. Vue.set 的原理?

```js
 ../observer/index 中找出set函数
function set (target: Array<any> | Object, key: any, val: any): any {
  if (process.env.NODE_ENV !== 'production' &&
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(`Cannot set reactive property on undefined, null, or primitive value: ${(target: any)}`)
  }
  // 数组的情况下，通过调用Vue中的 arrayMethods 下面的 7个方法之一 
  // splice push pop unshift shift reverse sort，通过调用这些方法可以监听数据，
  // 并把数组里面的每一项进行监听
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key)
    target.splice(key, 1, val)
    return val
  }
  // 通过给对象赋值
  if (key in target && !(key in Object.prototype)) {
    target[key] = val
    return val
  }
  const ob = (target: any).__ob__
  if (target._isVue || (ob && ob.vmCount)) {
    process.env.NODE_ENV !== 'production' && warn(
      'Avoid adding reactive properties to a Vue instance or its root $data ' +
      'at runtime - declare it upfront in the data option.'
    )
    return val
  }
  if (!ob) {
    target[key] = val
    return val
  }
  // 监听当前对象
  defineReactive(ob.value, key, val)
  // 收集依赖
  ob.dep.notify()
  return val
}
```



#### 4.为什么Vue3.0proxy解决了什么问题，为什么性能更好？

```js
Vue2.0
对象：添加属性的时候 obj.a = 1 会无法被Vue2劫持，必须使用Vue2提供的$set方法来进行更新
因为defineProperty只能对当前对象中的属性进行监听一个个去监听，新增加进来的，需要重新使用defineProperty，但是Vue是不知道什么时候去使用defineProperty。

Vue3.0中，使用proxy来进行数据代理就完全没有这个顾虑了
const p = new Proxy({
    a: 1,
    b: 2,
}, {
    get: function(obj, value) {
        console.log('get', obj, value);
        return Reflect.get(obj, value);
    },
    set: function(obj, prop, value) {
        console.log('set', obj, prop, value);
        return Reflect.set(obj, prop, value);
    },
})

proxy对于数据的代理，是能够响应新增的属性，当新增一个属性的时候，可以响应到get中，对当前对象进行代理


数组:Vue针对数组是多做了一层处理，代理了数组的7个方法，这是因为使用Object.defineProperty在数组上面天然存在劣势，所以数组的修改也是无法侦听的，需要通过方法去修改值。
const a = new Proxy([1,2], {
    get: function(obj, prop) {
        console.log('get', obj, prop);
        return Reflect.get(obj, prop);
    },
    set: function(obj, prop, value) {
        console.log('set', obj, prop, value);
        return Reflect.set(obj, prop, value);
    },
});
a.push(1);

get [1,2] push
get [1,2] length
set [1,2] 2 3
set [1,2, 3] length 3

由于proxy会触发两次，Vue3只会在prop为length值才进行更新

Vue2 如果没有设置Object.freeze默认递归data里面的数据做响应式处理，所以不建议在data中的数据定义嵌套太多层，Vue3的proxy是懒递归，不会一上来就递归，性能就相对好点
```





#### Vue compile 过程详细说一下，指令、插值表达式等 vue 语法如何生效的?

```
```



#### Vue 中内置组件transition、transition-group 的源码实现原理?

#### 知道 Vue 生命周期内部怎么实现的么 ?

```
将渲染的组件，父组件子组件的生命周期钩子，推进一个数组，然后通过callHook函数执行相应的钩子函数
```

