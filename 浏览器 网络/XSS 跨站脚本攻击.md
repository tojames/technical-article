# XSS「Cross Site Script」

我们知道了同源策略可以隔离各个站点之间的 DOM 交互、页面数据和网络通信，虽然严格的同源策略会带来更多的安全，但是也束缚了 Web。**这就需要在安全和自由之间找到一个平衡点，所以我们默认页面中可以引用任意第三方资源**，然后又引入 CSP 策略来加以限制；默认 XMLHttpRequest 和 Fetch 不能跨站请求资源，然后又通过 CORS 策略来支持其跨域。

所以安全性降低了，为了更好的技术应用，同时也带来了更多的安全隐患，如XSS，CSRF。

## 什么是XSS

> Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。
>
> 其实防范的宗旨是--增加攻击的难度，降低攻击的后果



## XSS攻击类型

### 第一种 反射型

在一个反射型 XSS 攻击过程中，恶意 JavaScript 脚本属于用户发送给网站请求中的一部分，随后网站又把恶意 JavaScript 脚本返回给用户。当恶意 JavaScript 脚本在用户页面中被执行时，黑客就可以利用该脚本做一些恶意操作。

```
场景：比如在一个网站上面，弹出来一个广告「性感荷官...」,用户这时候点击进去了，访问了恶意广告的服务器，服务器这时候直接返回一个<script>带各种恶意操作的脚本<script>，然后浏览器获取到了返回的内容，就会像平时加载脚本一样加载这个新的script，接着就会执行里面的代码，然后这个网站就会受到攻击了。

场景2:还是一个网站，弹出来一个广告「性感荷官...」,用户这时候点击进去了，通过攻击者精心设计的请求参数，跑服务器的缺陷，返回的数据到前端也是可以收到攻击的
关于反射性场景很多，如网站搜索、跳转等。

攻击方式：诱导用户自己点开（一次性），可能发送一些用户数据给脚本。
防范：1.这种属于外链的注入那我们能做的就是保证用户凭证的安全，可以在后端设置httponly，但是前端就不能访问了，会有一些不必要的限制，还可以加校验来源。这只是其中的一种反射型场景
```



### 第二种 DOM 型

DOM型攻击都是直接修改dom结构的

```
1.攻击方式DOM base 修改属性插入内容document.write...，改变dom结构后可以发起攻击 
场景：当恶意用户输入的东西存在恶意脚本，也会造成攻击
可以通过encodeURI进行转码

2.基于 DOM 的 XSS 攻击是不牵涉到页面 Web 服务器的。具体来讲，黑客通过各种手段将恶意脚本注入用户的页面中，比如通过网络劫持在页面传输过程中修改 HTML 页面的内容，这种劫持类型很多，有通过 WiFi 路由器劫持的，有通过本地恶意软件来劫持的，它们的共同点是在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据。

通过CSP方式去防范。
```



### 第三种 储存型

```
恶意的脚本存储到了服务器上，每次访问数据库的时候都会去触发，伤害最大
恶意用户通过输入恶意的脚本，提交数据给后台。
场景：当一个网络论坛里面的评论模块，有一些评论，恶意用户在上面评论了一段恶意脚本，然后提交到数据库，以后所有的用户直接访问了这个模块的内容就会执行这个脚本，造成攻击
这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。

防范：前端：需要校验过滤。
或者在输出的时候过滤，对各种奇怪的符号处理
	如：
			& === &amp 
			" === "&quot"
			' === &apos
			< === &lt
			> === &gt
可以通过encodeURI进行转码


```



## 如何防范XSS攻击呢？

我们知道存储型 XSS 攻击和反射型 XSS 攻击都是需要经过 Web 服务器来处理的，因此可以认为这两种类型的漏洞是服务端的安全漏洞。而基于 DOM 的 XSS 攻击全部都是在浏览器端完成的，因此基于 DOM 的 XSS 攻击是属于前端的安全漏洞。

它们都有一个共同点，那就是首先往浏览器中注入恶意脚本，然后再通过恶意脚本将用户信息发送至黑客部署的恶意服务器上。**所以要阻止 XSS 攻击，我们可以通过阻止恶意 JavaScript 脚本的注入和恶意消息的发送来实现。**

**XSS注入的方式**

- 在HTML中，恶意内容以script标签注入，如反射性注入脚本。

  ​	通过下面提及的CSP防范

- 在标签的 href、src 等属性中，包含 javascript: 等可执行代码。

  ​	通过输入过滤，如果不行会有CSP防范

- 在内联的 JavaScript 中，拼接的数据突破了原本的限制（字符串，变量，方法名等），如eval()、setTimeout()、setInterval() 可以拼接数据并被执行。

  跟我们平时写代码的习惯相关了，一般很少有人这么写的

- 在 onload、onerror、onclick 等事件中，注入不受控制代码。



### 输入脚本进行过滤或转码

> 如果开发者没有将用户输入的文本进行合适的过滤，就贸然插入到 HTML 中，这很容易造成注入漏洞。攻击者可以利用漏洞，构造出恶意的代码指令，进而利用恶意代码危害数据安全。

前端/服务端对于明确的输入类型，例如数字、URL、电话号码、邮件地址等等内容，进行输入过滤。

但是有些时候，对于一些输入过滤是可能存在乱码的情况。



### 充分利用 CSP

```html
<meta http-equiv="Content-Security-Policy" content="default-src 'self'; img-src https://*; child-src 'none';">

```

虽然前端/服务端执行过滤或者转码可以阻止 XSS 攻击的发生，但完全依靠前端/服务器端依然是不够的，我们还需要把 CSP 等策略充分地利用起来，以降低 XSS 攻击带来的风险和后果。

实施严格的 CSP 可以有效地防范 XSS 攻击，具体来讲 CSP 有如下几个功能：

- 限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个 JavaScript 文件也是无法被加载的；
- 禁止向第三方域提交数据，这样用户数据也不会外泄；
- 禁止执行内联脚本和未授权的脚本；
- 还提供了上报机制，这样可以帮助我们尽快发现有哪些 XSS 攻击，以便尽快修复问题。因此，利用好 CSP 能够有效降低 XSS 攻击的概率。



### 使用 HttpOnly 属性

由于很多 XSS 攻击都是来盗用 Cookie 的，因此还可以通过使用 HttpOnly 属性来保护我们 Cookie 的安全。

通常服务器可以将某些 Cookie 设置为 HttpOnly 标志，HttpOnly 是服务器通过 HTTP 响应头来设置的，下面是打开 Google 时，HTTP 响应头中的一段：

```
set-cookie: id=1000 expires=Sat, 18-Apr-2022 06:52:22 GMT; path=/; domain=.google.com; HttpOnly
```

### 其他的办法

#### 输入内容长度控制

对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止 XSS 发生，但可以增加 XSS 攻击的难度。

#### 验证码

即使网站被攻击了，核心信息防止脚本冒充用户提交危险操作。

## 总结

```
如何防范呢？
	输入过滤
在用户提交时，由前端过滤输入，然后提交到后端。这样做是否可行呢？
答案是不可行。一旦攻击者绕过前端过滤，直接构造请求，就可以提交恶意代码了。
那么，换一个过滤时机：后端在写入数据库前，对输入进行过滤，然后把“安全的”内容，返回给前端。这样是否可行呢？
我们举一个例子，一个正常的用户输入了 5 < 7 这个内容，在写入数据库前，被转义，变成了 5 &lt; 7。
问题是：在提交阶段，我们并不确定内容要输出到哪里。
这里的“并不确定内容要输出到哪里”有两层含义：
用户的输入内容可能同时提供给前端和客户端，而一旦经过了 escapeHTML()，客户端显示的内容就变成了乱码( 5 &lt; 7 )。
在前端中，不同的位置所需的编码也不同。
当 5 &lt; 7 作为 HTML 拼接页面时，可以正常显示：
<div title="comment">5 &lt; 7</div>
当 5 &lt; 7 通过 Ajax 返回，然后赋值给 JavaScript 的变量时，前端得到的字符串就是转义后的字符。这个内容不能直接用于 Vue 等模板的展示，也不能直接用于内容长度计算。不能用于标题、alert 等。
所以，输入侧过滤能够在某些情况下解决特定的 XSS 问题，但会引入很大的不确定性和乱码问题。在防范 XSS 攻击时应避免此类方法。
当然，对于明确的输入类型，例如数字、URL、电话号码、邮件地址等等内容，进行输入过滤还是必要的。
既然输入过滤并非完全可靠，我们就要通过“防止浏览器执行恶意代码”来防范 XSS。这部分分为两类：
防止 HTML 中出现注入。
防止 JavaScript 执行时，执行恶意代码。


预防存储型和反射型 XSS 攻击
存储型和反射型 XSS 都是将恶意代码，插入到响应 HTML 里的，攻击者刻意编写的“数据”被内嵌到“代码”中，被浏览器所执行。
预防这两种漏洞，有两种常见做法：
改成纯前端渲染，把代码和数据分隔开。
对 HTML 做充分转义。
纯前端渲染
纯前端渲染的过程：
浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据。
然后浏览器执行 HTML 中的 JavaScript。
JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。
在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本（.innerText），还是属性（.setAttribute），还是样式（.style）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了。

但纯前端渲染还需注意避免 DOM 型 XSS 漏洞（例如 onload 事件和 href 中的 javascript:xxx 等，请参考下文”预防 DOM 型 XSS 攻击“部分）。

在很多内部、管理系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题。

转义 HTML
如果拼接 HTML 是必要的，就需要采用合适的转义库，对 HTML 模板各处插入点进行充分的转义。


预防 DOM 型 XSS 攻击
DOM 型 XSS 攻击，实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了。
在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等。
如果用 Vue/React 技术栈，并且不使用 v-html/dangerouslySetInnerHTML 功能，就在前端 render 阶段避免 innerHTML、outerHTML 的 XSS 隐患。

DOM 中的内联事件监听器，如 location、onclick、onerror、onload、onmouseover 等，<a> 标签的 href 属性，JavaScript 的 eval()、setTimeout()、setInterval() 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。

其他 XSS 防范措施
虽然在渲染页面和执行 JavaScript 时，通过谨慎的转义可以防止 XSS 的发生，但完全依靠开发的谨慎仍然是不够的。以下介绍一些通用的方案，可以降低 XSS 带来的风险和后果。


Content Security Policy
严格的 CSP 在 XSS 的防范中可以起到以下的作用：

禁止加载外域代码，防止复杂的攻击逻辑。
禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。
禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。
禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。
合理使用上报可以及时发现 XSS，利于尽快修复问题。
关于 CSP 的详情，请关注前端安全系列后续的文章。

输入内容长度控制
对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止 XSS 发生，但可以增加 XSS 攻击的难度。

其他安全措施
HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。
验证码：防止脚本冒充用户提交危险操作。

那我们日常工作中怎么减少XSS攻击的可能性？
利用模板引擎 开启模板引擎自带的 HTML 转义功能。例如： 在 ejs 中，尽量使用 <%= data %> 而不是 <%- data %>； 在 doT.js 中，尽量使用 {{! data } 而不是 {{= data }； 在 FreeMarker 中，确保引擎版本高于 2.3.24，并且选择正确的 freemarker.core.OutputFormat。
避免内联事件 尽量不要使用 onLoad="onload('{{data}}')"、onClick="go('{{action}}')" 这种拼接内联事件的写法。在 JavaScript 中通过 .addEventlistener() 事件绑定会更安全。
避免拼接 HTML 前端采用拼接 HTML 的方法比较危险，如果框架允许，使用 createElement、setAttribute 之类的方法实现。或者采用比较成熟的渲染框架，如 Vue/React 等。
时刻保持警惕 在插入位置为 DOM 属性、链接等位置时，要打起精神，严加防范。
通过 CSP、输入长度配置、接口安全措施等方法，增加攻击的难度，降低攻击的后果。
主动检测和发现 可使用 XSS 攻击字符串和自动扫描工具寻找潜在的 XSS 漏洞。
```



