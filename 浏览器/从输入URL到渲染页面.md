# 从输入 URL 到渲染页面

这道面试题考察的是浏览器的工作原理。

> `浏览器进程`:主要负责用户交互、子进程管理和文件储存等功能。
>
> `网络进程`:是面向渲染进程和浏览器进程等提供网络下载功能。
>
> `渲染进程`:主要职责是把从网络下载的 HTML、JavaScript、CSS、图片等资源解析为可以显示和交互的页面。因为渲染进程所有的内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对系统进行攻击，所以运行在渲染进程里面的代码是不被信任的。这也是为什么 Chrome 会让渲染进程运行在安全沙箱里，就是为了保证系统的安全。



**整个流程。**

<img src="../../static/images/image-20210818140903818.png" alt="image-20210818140903818" style="zoom:50%;" />



#### 第一步：用户输入

> 首先，浏览器进程接收到用户输入的 URL 请求，浏览器进程便将该 URL 转发给网络进程。然后，在网络进程中发起真正的 URL 请求。

##### 用户输入后详细流程

**1.当用户在地址栏中输入一个查询关键字时**，有两种情况

- 搜索内容：地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 URL。

- 请求的 URL：比如输入的是baidu.com，那么地址栏会根据规则，把这段内容加上协议，合成为完整的 URL，如 https://www.baidu.com/，还有当输入http://www.baidu.com会变成 https://www.baidu.com/

  百度会先返回307 Internal Redirect，然后在响应头中返回 Location: https://www.baidu.com/。告诉浏览器重新定向到那边去。
  
  <img src="../../static/images/image-20210818113450004.png" alt="image-20210818113450004" style="zoom:50%;" />



**2.当用户输入关键字并键入回车之后**，检测是否有beforeunload事件

这意味着当前页面即将要被替换成新的页面，不过在这个流程继续之前，浏览器还给了当前页面一次执行 beforeunload 事件的机会，beforeunload 事件允许页面在退出之前执行一些数据清理操作，还可以询问用户是否要离开当前页面，比如当前页面可能有未提交完成的表单等情况，因此用户可以通过 beforeunload 事件来取消导航，让浏览器不再执行任何后续工作。



<img src="../../static/images/image-20210818104924276.png" alt="image-20210818104924276" style="zoom:50%;text-align:left" />



从图中可以看出，当浏览器刚开始加载一个地址之后，标签页上的图标便进入了加载状态。但此时图中页面显示的依然是之前打开的页面内容，并没立即替换为百度首页的页面。因为需要等待**提交文档阶段**「后面解析」，页面内容才会被替换。



#### 第二步：URL请求过程

> 接下来，便进入了页面资源请求过程。这时，浏览器进程会通过进程间通信（IPC）把 URL 请求发送至网络进程，网络进程接收到 URL 请求后，会在这里发起真正的 URL 请求。

##### 请求过程详细流程

**1.缓存检查**
网络进程会查找本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进入网络请求流程。**`缓存检查`是复杂的过程，可以在当前目录找到缓存相关文章**。

**2.DNS解析**
在请求前的第一步是要进行 DNS 解析，以获取请求域名的服务器 IP 地址。然后进行TCP连接，如果请求协议是 HTTPS，那么还需要建立 TLS 连接。**这里涉及到了`DNS解析`、`TCP连接`、`TLS连接`可以在当前目录找到相关文章**。

**3.处理返回到的数据**

服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应头的内容了，对于状态码200，将解析后的数据传递给浏览器进程。
浏览器进程接收到网络进程的响应头数据之后，发送“提交导航 (CommitNavigation)”消息到渲染进程；
渲染进程接收到“提交导航”的消息之后，便开始准备接收 HTML 数据，接收数据的方式是直接和网络进程建立数据管道；
最后渲染进程会向浏览器进程“确认提交”，这是告诉浏览器进程：“已经准备好接受和解析页面数据了”。
浏览器进程接收到渲染进程“提交文档”的消息之后，便开始移除之前旧的文档，然后更新浏览器进程中的页面状态。后面就可以开始走渲染流程了。

**当我们遇到状态码是其他的呢？**

**这里设计到状态码的，可以在当前目录找到相关的文章**

比如遇到的状态码是301/302/306/307，这些都是重定向的状态码

那么说明服务器需要浏览器重定向到其他 URL。这时网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求，一切又重头开始了，刚刚在用户输入baidu的时候已经讲过重定向的原理的。

**响应数据类型处理怎么处理呢？**

根据响应头去处理。

Content-Type 是 HTTP 头中一个非常重要的字段， 它告诉浏览器服务器返回的响应体数据是什么类型，然后浏览器会根据 Content-Type 的值来决定如何显示响应体的内容。

Content-Type: text/html;charset=utf-8：是一个html类型，那么浏览器就会交给渲染进程渲染这个html。

Content-Type: application/octet-stream：是一个字节流类型，那么浏览器浏览器就会交给下载管理器去下载。



#### 第三步：准备渲染

> 网络进程将请求到的文档传给浏览器主进程，主进程通知渲染进程，渲染进程和网络进程简历连接管道， 将网络进程请求到的html文档，渲染到页面上。

渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。

##### 文档提交

首先当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息；

渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”；

等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程；

浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。

当我们输入了地址不会马上跳转，因为资源请求，解析，数据传递的操作。



默认情况下，Chrome 会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。但是，也有一些例外，在某些情况下，浏览器会让多个页面直接运行在同一个渲染进程中。目前测试了掘金、简书、csdn、github、极客时间，只有极客时间是可以多个页面是渲染进程共用的。

<img src="../../static/images/image-20210818135652840.png" alt="image-20210818135652840" style="zoom:50%;" />

#### **第四步：页面渲染**

> 当浏览器进程确定文档提交了，渲染进程便开始页面解析和子资源加载了，当页面加载完毕渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画
>
> ![image-20210818143641394](../../static/images/image-20210818143641394.png)

##### 渲染详细过程

**1.构建 DOM 树**

由于浏览器无法理解html，所以需要转换为dom树，dom树其实和html结构是非常相似的，但是dom树是存储在内存中，可以通过JavaScript访问的到。

**2.样式计算**

​	2.1.转换样式

​		同样无法理解css，所以需要转换为styleSheets。document.styleSheets 可查看

​	2.2.转换样式表中的属性值，使其标准化

```css
body { font-size: 2em }
p {color:blue;}
span {display: none}
div {font-weight: bold}
div p {color:green;}
div {color:red; }

标准化的过程是
body { font-size: 32px }
p {color:rgb(0,0,255);}
span {display: none}
div {font-weight: 700}
div p {color:rgb(0,128,0);}
div {color:rgb(255,0,0); }
```

​	2.3计算dom节点的具体某个节点的样式

​		样式计算阶段的目的是为了计算出 DOM 节点中每个元素的具体样式，在计算过程中需要遵守 CSS 的继承和层叠两个规则。这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 ComputedStyle 的结构内

DOM 元素最终的计算样式，可以打开 Chrome 的“开发者工具”，选择第一个“element”标签，然后再选择“Computed”子标签中可以查看

UserAgent 样式，它是浏览器提供的一组默认样式，如果你不提供任何样式，默认使用的就是 UserAgent 样式。

<img src="../../static/images/image-20210818154706551.png" alt="image-20210818154706551" style="zoom:50%;" />



<img src="../../static/images/image-20210818154741524.png" alt="image-20210818154741524" style="zoom:50%;" />



**3.布局阶段**

现在，我们有 DOM 树和 DOM 树中元素的样式，但这还不足以显示页面，因为我们还不知道 DOM 元素的几何位置信息。**那么接下来就需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局**。

3.1创建布局树

你可能注意到了 DOM 树还含有很多不可见的元素，比如 head 标签，还有使用了 display:none 属性的元素。所以在显示之前，**我们还要额外地构建一棵只包含可见元素布局树。**

<img src="../../static/images/image-20210818155335095.png" alt="image-20210818155335095" style="zoom:50%;" />

为了构建布局树，浏览器大体上完成了下面这些工作：

遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中；

而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，再比如 body.p.span 这个元素，因为它的属性包含 dispaly:none，所以这个元素也没有被包进布局树。

3.2布局计算

现在我们有了一棵完整的布局树。那么接下来，就要计算布局树节点的坐标位置了。布局的计算过程非常复杂。

在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以布局树既是输入内容也是输出内容，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内容区分开来。针对这个问题，Chrome 团队正在重构布局代码，下一代布局系统叫 LayoutNG，试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单。

**4.分层**

目前阶段还不能绘制，因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-index做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree），正是这些图层叠加在一起构成了最终的页面图像。

在chrome查看图层 https://www.cnblogs.com/HenrysBlogs/p/13419843.html

<img src="../../static/images/image-20210818162307541.png" alt="image-20210818162307541" style="zoom:50%;" />

可以看到的是右边的图是拥有很多的图层的，它合成后是左边的图。

创建新的图层的条件

4.1 第一点，拥有层叠上下文属性的元素会被提升为单独的一层

页面是个二维平面，但是层叠上下文能够让 HTML 元素具有三维概念，这些 HTML 元素按照自身属性的优先级分布在垂直于这个二维平面的 z 轴上。你可以结合下图来直观感受下：

<img src="../../static/images/image-20210818163730808.png" alt="image-20210818163730808" style="zoom:50%;" />



4.2需要剪裁（clip）的地方也会被创建为图层。

```html
  <style>
    div {
      width: 200px;
      height: 200px;
      overflow: auto;
      background: gray;
    }
  </style>
  <body>
    <div>
      <p>所以元素有了层叠上下文的属性或者需要被剪裁，那么就会被提升成为单独一层，你可以参看下图：</p>
      <p>从上图我们可以看到，document层上有A和B层，而B层之上又有两个图层。这些图层组织在一起也是一颗树状结构。</p>
      <p>
        图层树是基于布局树来创建的，为了找出哪些元素需要在哪些层中，渲染引擎会遍历布局树来创建层树（Update LayerTree）。
      </p>
    </div>
  </body>
```



<img src="../../static/images/image-20210818164534852.png" alt="image-20210818164534852" style="zoom:50%;" />



**5.绘制**

在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制

从图中可以看出，绘制列表中的指令其实非常简单，就是让其执行一个简单的绘制操作，比如绘制粉色矩形或者黑色的线等。而绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。所以在图层绘制阶段，输出的内容就是这些待绘制列表。

<img src="../../static/images/image-20210818165831555.png" alt="image-20210818165831555" style="zoom:50%;" />



**6.光栅化和合成**

绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。你可以结合下图来看下渲染主线程和合成线程之间的关系

<img src="../../static/images/image-20210818171101546.png" alt="image-20210818171101546" style="zoom:50%;" />

如上图所示，当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程，那么接下来合成线程是怎么工作的呢？

通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口（viewport）。在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。基于这个原因，合成线程会将图层划分为图块（tile），这些图块的大小通常是 256x256 或者 512x512，如下图所示：

<img src="../../static/images/image-20210819091637690.png" alt="image-20210819091637690" style="zoom:50%;" />

然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的，运行方式如下图所示：

<img src="../../static/images/image-20210819091859716.png" alt="image-20210819091859716" style="zoom:50%;" />

通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。相信你还记得，GPU 操作是运行在 GPU 进程中，如果栅格化操作使用了 GPU，那么最终生成位图的操作是在 GPU 中完成的，这就涉及到了跨进程操作。具体形式你可以参考下图：

<img src="../../static/images/image-20210819091929432.png" alt="image-20210819091929432" style="zoom:50%;" />

从图中可以看出，渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块的位图，并保存在 GPU 的内存中。



**7.合成和显示**

一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。

浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。

到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面了





**总结**

<img src="../../static/images/image-20210819092752032.png" alt="image-20210819092752032" style="zoom:50%;" />



1.渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。

2.渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。

3.创建布局树，并计算元素的布局信息。

4.对布局树进行分层，并生成分层树。

5.为每个图层生成绘制列表，并将其提交到合成线程。

6.合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。

7.合成线程发送绘制图块命令 DrawQuad 给浏览器进程。浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。









相关概念

有了上面介绍渲染流水线的基础，我们再来看看三个和渲染流水线相关的概念——“重排”“重绘”和“合成”。理解了这三个概念对于你后续 Web 的性能优化会有很大帮助。

1. 更新了元素的几何属性（重排）你可先参考下图：

<img src="../../static/images/image-20210819093228156.png" alt="image-20210819093228156" style="zoom:50%;" />

从上图可以看出，如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。无疑，重排需要更新完整的渲染流水线，所以开销也是最大的。



2. 更新元素的绘制属性（重绘）

   接下来，我们再来看看重绘，比如通过 JavaScript 更改某些元素的背景颜色，渲染流水线会怎样调整呢？你可以参考下图：

   <img src="../../static/images/image-20210819093441207.png" alt="image-20210819093441207" style="zoom:50%;" />

从图中可以看出，如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。

3. 直接合成阶段

   那如果你更改一个既不要布局也不要绘制的属性，会发生什么变化呢？渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成。具体流程参考下图：

   <img src="../../static/images/image-20210819093540009.png" alt="image-20210819093540009" style="zoom:50%;" />

在上图中，我们使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。

至于如何用这些概念去优化页面，我们会在后面相关章节做详细讲解的，这里你只需要先结合“渲染流水线”弄明白这三个概念及原理就行。



如果下载 CSS 文件阻塞了，会阻塞 DOM 树的合成吗？会阻塞页面的显示吗？

```html
当从服务器接收HTML页面的第一批数据时，DOM解析器就开始工作了，在解析过程中，如果遇到了JS脚本，如下所示：
<html>
    <body>
        hello world
        <script>
        document.write("--foo")
        </script>
    </body>
</html>
那么DOM解析器会先执行JavaScript脚本，执行完成之后，再继续往下解析。

那么第二种情况复杂点了，我们内联的脚本替换成js外部文件，如下所示：
<html>
    <body>
        hello world
        <script type="text/javascript" src="foo.js"></script>
    </body>
</html>
这种情况下，当解析到JavaScript的时候，会先暂停DOM解析，并下载foo.js文件，下载完成之后执行该段JS文件，然后再继续往下解析DOM。这就是JavaScript文件为什么会阻塞DOM渲染。

我们再看第三种情况，还是看下面代码：
<html>
    <head>
        <style type="text/css" src = "theme.css" />
    </head>
    <body>
        <p>hello world</p>
        <script>
            let e = document.getElementsByTagName('p')[0]
            e.style.color = 'blue'
        </script>
    </body>
</html>
当我在JavaScript中访问了某个元素的样式，那么这时候就需要等待这个样式被下载完成才能继续往下执行，所以在这种情况下，CSS也会阻塞DOM的解析。


所以JS和CSS都有可能会阻塞DOM解析，关于详细信息我们会在后面的章节中详细介绍。
```



参考：https://juejin.cn/post/6844903565610188807

**CRP（Critical Rendering Path）关键渲染路径**

> 关键渲染路径是指浏览器从最初接收请求来的 HTML、CSS、javascript 等资源，然后解析、构建树、渲染布局、绘制，最后呈现给客户能看到的界面这整个过程。

浏览器渲染过程：

```
1.解析HTML生成DOM树。
2.解析CSS生成CSSOM规则树。
3.将DOM树与CSSOM规则树合并在一起生成渲染树。
4.遍历渲染树开始布局，计算每个节点的位置大小信息。
5.将渲染树每个节点绘制到屏幕。
```

##### 7.1.构建 DOM 树

当浏览器接收到服务器响应来的 HTML 文档后，会遍历文档节点，生成 DOM 树。

需要注意的是，DOM 树的生成过程中可能会被 CSS 和 JS 的加载执行阻塞。渲染阻塞问题下文会讲。

##### 7.2.构建 CSSOM 规则树

浏览器解析 CSS 文件并生成 CSS 规则树，每个 CSS 文件都被分析成一个 StyleSheet 对象，每个对象都包含 CSS 规则。CSS 规则对象包含对应于 CSS 语法的选择器和声明对象以及其他对象。

**渲染阻塞**

当浏览器遇到一个 script 标记时，DOM 构建将暂停，直至脚本完成执行，然后继续构建 DOM。每次去执行 JavaScript 脚本都会严重地阻塞 DOM 树的构建，如果 JavaScript 脚本还操作了 CSS 和 DOM，而正好这个 CSS 和 DOM 还没有下载和构建，浏览器甚至会延迟脚本执行和构建 DOM，直至完成其 CSSOM 的下载和构建。

所以，script 标签的位置很重要。实际使用时，可以遵循下面两个原则：

CSS 优先：引入顺序上，CSS 资源先于 JavaScript 资源。
JS 置后：我们通常把 JS 代码放到页面底部，且 JavaScript 应尽量少影响 DOM 的构建。

当解析 html 的时候，会把新来的元素插入 dom 树里面，同时去查找 css，然后把对应的样式规则应用到元素上，查找样式表是按照从右到左的顺序去匹配的。

例如： div p {font-size: 16px}，会先寻找所有 p 标签并判断它的父标签是否为 div 之后才会决定要不要采用这个样式进行渲染）。
所以，我们平时写 CSS 时，尽量用 id 和 class，千万不要过渡层叠。

##### 7.3.构建渲染树

通过 DOM 树和 CSS 规则树我们便可以构建渲染树。浏览器会先从 DOM 树的根节点开始遍历每个可见节点。对每个可见节点，找到其适配的 CSS 样式规则并应用。

渲染树构建完成后，每个节点都是可见节点并且都含有其内容和对应规则的样式。这也是渲染树与 DOM 树的最大区别所在。渲染树是用于显示，那些不可见的元素当然就不会在这棵树中出现了，譬如。除此之外，display 等于 none 的也不会被显示在这棵树里头，但是 visibility 等于 hidden 的元素是会显示在这棵树里头的。

##### 7.4.渲染树布局

布局阶段会从渲染树的根节点开始遍历，然后确定每个节点对象在页面上的确切大小与位置，布局阶段的输出是一个盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小。

##### 7.5.渲染树绘制

在绘制阶段，遍历渲染树，调用渲染器的 paint()方法在屏幕上显示其内容。渲染树的绘制工作是由浏览器的 UI 后端组件完成的。

**reflow 与 repaint：**

根据渲染树布局，计算 CSS 样式，即每个节点在页面中的大小和位置等几何信息。HTML 默认是流式布局的，CSS 和 js 会打破这种布局，改变 DOM 的外观样式以及大小和位置。这时就要提到两个重要概念：replaint 和 reflow。
replaint：屏幕的一部分重画，不影响整体布局，比如某个 CSS 的背景色变了，但元素的几何尺寸和位置不变。
reflow： 意味着元件的几何尺寸变了，我们需要重新验证并计算渲染树。是渲染树的一部分或全部发生了变化。这就是 Reflow，或是 Layout。
所以我们应该尽量减少 reflow 和 replaint，我想这也是为什么现在很少有用 table 布局的原因之一。

display:none 会触发 reflow，visibility: hidden 属性并不算是不可见属性，它的语义是隐藏元素，但元素仍然占据着布局空间，它会被渲染成一个空框，所以 visibility:hidden 只会触发 repaint，因为没有发生位置变化。

有些情况下，比如修改了元素的样式，浏览器并不会立刻 reflow 或 repaint 一次，而是会把这样的操作积攒一批，然后做一次 reflow，这又叫异步 reflow 或增量异步 reflow。
有些情况下，比如 resize 窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。

如果在 body 中间插入一段 script，执行一个循环特别大的脚本，页面表现是什么样的？

页面会堵塞，无响应知道脚本执行完毕，这种体验太差了。

我们应该考虑这种代码应该重构，具体情况就有很多考虑的方式了。

脚本使用 defer/async，如果脚本必须提前执行，那代码是不是改优化。
