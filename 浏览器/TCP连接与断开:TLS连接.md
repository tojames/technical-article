

#### **第四步：TCP 三次握手**

接下来就是利用 IP 地址和服务器建立 TCP 连接。连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。

> UDP 是即时通信。
>
> - seq 序号，用来标识从 TCP 源端向目的端发送的字节流，发起方发送数据时对此进行标记
> - ack 确认序号： 表示期望下一次应该接受到的报文的第一个字节的序号，若 ack = N 则表示，到序号 N-1 为止的所有的数据都已经正确的收到了。只有 ACK 标志位为 1 时，确认序号字段才有效，ack=seq+1。建立连接后，所有传送的报文段都必须把 ACK 置为 1。
>
> - 标志位
>   - ACK：确认序号有效 ACK 是一个对数据包的确认，当正确收到数据包后，接收端会发送一个 ACk 给发送端，里面会说明对那个数据包进行确认，每个数据包里都会有一个序列号，如果收到的数据包有误，或错序，还会申请重发，NAK 是一个否定的回答，ACK 是确定回答，这样保证数据的正确传输，这是 TCP 协议的传输机制，被称为面向连接的。
>   - RST：重置连接
>   - SYN：发起一个新连接，当两台计算机在 TCP 连接上进行会话时，连接一定会首先被初始化。完成这项任务的包叫作 SYN。
>   - FIN：释放一个连接 带有该标志置位的数据包用来结束一个 TCP 回话，但对应端口仍处于开放状态，准备接收后续数据

**三次握手流程**

```
第一次握手客户端发送请求「新链接SYN，序号seq」链接给服务器。
	过程是SYN包初始化完成，准备好连接了SYN=1，并且发送了发送数据包的第一个字节的序号，seq=x。
第二次握手服务器处理完处理返回「新链接SYN=1，确认序号有效ACK=1，返回新的序号seq=y，确认序号ack=x+1」
	接受到合法的连接请求然后也进行初始化SYN=1，并且确认ACK=1，还有ack = x+1，期望下次握手能拿到x+1的序号
	seq发送包的第一个字节的序号
第三次握手客户端「确认序号有效ACK=1， 返回新的序号seq=x+1，确认序号ack=y+1」
	这时候SYN是0就忽略了，不用再初始化了，确认ACK=1 然后期望下次收到的是 ack=y+1，并且seq = x+1，发送给服务器，完成它的期望。

然后就可以传输数据，http1.1是长链接，断开链接后才需要重新建立连接通道。
TCP作为一种可靠传输控制协议，其核心思想：既要保证数据可靠传输，又要提高传输的效率！

如果是两次握手？
	服务端无法确认客户端是否收到了信息，从而无法进行下一步建立通道的操作。
如果是四次握手？
	服务端如果是第四次握手的话，就会存在没有什么需要确认的信息回去了，因为需要确认的序号都已经确认好了，无需多余的操作。
```

![三次握手](../../static/images/三次握手.png)

#### **第五步：数据传输**

```
- HTTP报文
  - 请求报文
  - 响应报文
- 响应状态码
  - 200 OK
  - 202 Accepted ：服务器已接受请求，但尚未处理（异步）
  - 204 No Content：服务器成功处理了请求，但不需要返回任何实体内容
  - 206 Partial Content：服务器已经成功处理了部分 GET 请求（断点续传 Range/If-Range/Content-Range/Content-Type:”multipart/byteranges”/Content-Length….）
  - 301 Moved Permanently
  - 302 Move Temporarily
  - 304 Not Modified
  - 305 Use Proxy
  - 400 Bad Request : 请求参数有误
  - 401 Unauthorized：权限（Authorization）
  - 404 Not Found
  - 405 Method Not Allowed
  - 408 Request Timeout
  - 500 Internal Server Error
  - 503 Service Unavailable
  - 505 HTTP Version Not Supported
  - ……
```

#### **第六步：TCP 四次挥手**

> - 服务器端收到客户端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文
> - 但关闭连接时，当服务器端收到 FIN 报文时，很可能并不会立即关闭链接，所以只能先回复一个 ACK 报文，告诉客户端：”你发的 FIN 报文我收到了”，只有等到服务器端所有的报文都发送完了，我才能发送 FIN 报文，因此不能一起发送，故需要四步握手。
>
> Connection: keep-alive http1.0 需要设置，http1.1 默认就是长链接，一般页面关闭后就会关闭链接。

**为什么 TCP 需要四次挥手而不是 2 次挥手呢**

```
因为当客户端发送断开请求的时候，服务端需要马上回复客户端，但是服务端此时需要做一些比较费时的事情，所以先马上返回客户端‘好的，我正在处理后续的断开操作’，等处理完了，再去返回给客户端，接着客户端接收到了，回复一下服务端，就可以断开了

```

**四次挥手流程**

```
说明：当通信完成后，A和B都可以主动断开连接，例如，客户端A不主动断开连接，也不发送数据，B还等着接受，会占用服务器B的资源，B也可以主动断开连接。

  （1）A，B都处于ESTAB-LISHED建立连接状态。当A发送完数据后，想要断开连接，向B发送FIN=1（1代表请求断开连接），seq=u（这次发送的包，在我这所排的序号），发送后，A进入FIN-WAIT-1 终止等待1状态。

（2）当B收到A的请求后，回复ACK=1（确认收到），seq=v（这个包在我这，即在服务器B这排序为v，因为之前传输数据传输了很多包，这个排序不确定），ack=u+1（请求下一个发送的包为u+1，代表上一个包u已收到），当B发送后，进入CLOSE-WAIT关闭等待状态

（3）A收到B的回复后，进入FIN-WAIT-2终止等待2状态,因为B仅仅是回复了，我收到你的断开请求了，但是B没说是否同意断开，所以A继续等待。

（4）服务器B再次发送FIN=1（发送中断请求，即同意中断），ACK=1（确认收到），seq=w（这个包在我这，即在服务器B这排序为w，在请求关闭的同时，可能之前传送的包因网络问题，还在传输过程中，这中间服务器还会收到包，所以包排序不确定，有可能不是v+1，所以命名为w），ack=u+1（请求下一个发送的包为u+1，因为A已经进入终止等待状态，不会主动再发送包了，所以上次请求的包u+1,A没有发送，B这次继续发请求还是这个包），当B发送后进入LIST-ACK最后确认状态。

（5）当A收到B的中断请求后，发送回复，ACK=1（确认收到），seq=u+1（发送包u+1,这个包在我这排序为u+1，即上次B的回复中，请求下次发的包），ack=w+1（A会算出这个包在B那边的排序。上一个包为w，所以这个包为w+1）,发送完后A进入TIME-WAIT时间等待状态，因为网络中可能还有数据在传输，所以A要等待一段时间，确认这些数据发送成功。

（6）当B收到A的确认后，进入CLOSED关闭状态，断开与A连接，然后会迅速进入LISTEN收听状态，继续接受下一个客户端的请求连接。当A等待2MSL（TCP报文段在网络中的最大生存时间,RFC 1122标准的建议值是2min），进入CLOSED关闭状态，断开与服务器B连接。
```

![四次挥手](../../static/images/四次挥手.png)