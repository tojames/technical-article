# 类组件与函数组件

来自react作者dan说明 https://overreacted.io/how-are-function-components-different-from-classes/

> 在不同场景使用不同的组件，才能发挥出最大的作用。
>
> 不同点
>
> - 类组件需要继承class，函数组件不需要
> - 类组件可以访问生命周期方法，函数组件不能
> - 类组件中可以获取到实例化后的this，并基于this做各种各样的事情，函数组件不能
> - 类组件中可以定义并维护state，而函数组件不可以，需要通过useState



## 类组件

> 由于类组件继承了React.component，让它一开始就拥有各种各样的属性和方法，「打印this就可以看见」。
>
> 结论是：相比函数组件功能更齐全，使用起来很方便，但是相应的就是属性太多了，很多用不上。



**最标准的写法**

```js
	//1.创建组件
		class Weather extends React.Component{
			//构造器调用几次？ ———— 1次
			constructor(props){
				super(props)
				//初始化状态
				this.state = {isHot:false,wind:'微风'}
			 //解决changeWeather中this指向问题
       // 原理：先执行右侧代码，在Weather原型上找到了changeWeather，通过绑定this，赋值给当前实例				     				// this.changeWeather创建了一个栈来接收新的函数地址，接着render就可以调用当前实例的方法了。
				this.changeWeather = this.changeWeather.bind(this)
			}

			//render调用几次？ ———— 1+n次 1是初始化的那次 n是状态更新的次数
			render(){
				console.log('render');
				//读取状态
				const {isHot,wind} = this.state
        // 这里this.changeWeather 是通过onClick的函数，所以this是丢失的，通过再次bind后就不会丢失了。
				return <h1 onClick={this.changeWeather}>今天天气很{isHot ? '炎热' : '凉爽'}，{wind}</h1>
			}

			//changeWeather调用几次？ ———— 点几次调几次
			changeWeather(){
				//由于changeWeather是作为onClick的回调，所以不是通过实例调用的，是直接调用
				//类中的方法默认开启了局部的严格模式，所以changeWeather中的this为undefined
				
				console.log('changeWeather');
				//获取原来的isHot值
				const isHot = this.state.isHot
				//严重注意：状态必须通过setState进行更新,且更新是一种合并，不是替换。
				this.setState({isHot:!isHot})
				console.log(this);

				//严重注意：状态(state)不可直接更改，下面这行就是直接更改！！！
				//this.state.isHot = !isHot //这是错误的写法
			}
		}
		//2.渲染组件到页面
		ReactDOM.render(<Weather/>,document.getElementById('test'))
```

**开发写法**

> 开发这种写法可以为我们省下很多代码，把construcoor中的内容搬出来写。一种更加简洁的书写方式。

```js
//1.创建组件
	class Weather extends React.Component{
		//初始化状态，这就像普通的对象赋值操作一般
		state = {isHot:false,wind:'微风'}

		render(){
			const {isHot,wind} = this.state
			return <h1 onClick={this.changeWeather}>今天天气很{isHot ? '炎热' : '凉爽'}，{wind}</h1>
		}

		//自定义方法————要用赋值语句的形式+箭头函数，箭头函数去外层找this，找到初始化实例对象的 Weather 类。
		changeWeather = ()=>{
			const isHot = this.state.isHot
			this.setState({isHot:!isHot})
		}
	}
	//2.渲染组件到页面
	ReactDOM.render(<Weather/>,document.getElementById('test'))
		
```

## 

## 函数组件

> 轻量，学习成本低，并且可以解决很多问题。
>
> 函数组件会捕获render内部的状态，函数组件真正地把数据和渲染绑定到了一起。
>



### [Hooks](https://zh-hans.reactjs.org/docs/hooks-reference.html)

[自定义Hook](https://zh-hans.reactjs.org/docs/hooks-custom.html)

> React Hook 是React16.8版本新特性
>
> 可以让开发者在函数组件中使用state以及其他的React特性
>
> 函数组件更新状态都会重新执行render，但是useState的值是会被缓存起来，不会重新初始化。

为什么需要 React-Hooks？

```
优点
1.告别难以理解的 Class  
	主要是this 和生命周期函数这两点，如果想到还有其他也可以加上。

2.解决业务逻辑难以拆分的问题
	在生命周期中调用特别多的逻辑，复杂页面中这些代码看起来着实头疼。
	函数组件可以拆分更小的组件，可以把这些繁杂的操作按照逻辑上的关联拆分进不同的函数组件里：我们可以有专门管理订阅的函数组件、专门处理 DOM 的函数组件、专门获取数据的函数组件等。Hooks 能够帮助我们实现业务逻辑的聚合，避免复杂的组件和冗余的代码。
	其实类组件也可以啊，为什么我们不使用，因为重啊，而函数组件轻呀。

3.使状态逻辑复用变得简单可行；
  使用自定义Hook，Hooks 可以视作是 React 为解决状态逻辑复用这个问题所提供的一个原生途径。现在我们可以通过自定义 Hook，达到既不破坏组件结构、又能够实现逻辑复用的效果。

4.函数组件从设计思想上来看，更加契合 React 的理念。
 因为react 说过类组件和函数组件唯一不同是，函数组件会捕获render内部的状态
	
缺点
Hooks 暂时还不能完全地为函数组件补齐类组件的能力：比如 getSnapshotBeforeUpdate、componentDidCatch 这些生命周期，目前都还是强依赖类组件的。官方虽然立了“会尽早把它们加进来”的 Flag，但是说真的，这个 Flag 真的立了蛮久了……（扶额）

“轻量”几乎是函数组件的基因，这可能会使它不能够很好地消化“复杂”：我们有时会在类组件中见到一些方法非常繁多的实例，如果用函数组件来解决相同的问题，业务逻辑的拆分和组织会是一个很大的挑战。我个人的感觉是，从头到尾都在“过于复杂”和“过度拆分”之间摇摆不定，哈哈。耦合和内聚的边界，有时候真的很难把握，函数组件给了我们一定程度的自由，却也对开发者的水平提出了更高的要求。

Hooks 在使用层面有着严格的规则约束：这也是我们下个课时要重点讲的内容。对于如今的 React 开发者来说，如果不能牢记并践行 Hooks 的使用原则，如果对 Hooks 的关键原理没有扎实的把握，很容易把自己的 React 项目搞成大型车祸现场。


注意点：不要在循环、条件或嵌套函数中调用 Hook。
因为hooks 的底层是一个hook 接着一个hook 实例去对应起来的，但被代码破坏了其执行顺序，或者有些hook并没有执行就会导致 hook的状态对应不起来，控制台会提示 rendered fewer hooks than expected.this may be caused by an accidental early return statement. 
```



#### 1.State Hook

```jsx
State Hook 让函数组件也可以有state状态，并进行状态数据的读写操作
语法 const [xxx,setXxx] = React.useState(initValue)
 参数：第一次初始化指定的值在内部缓存
 返回值：包含2个元素的数组，第一个为内部当前状态值，第二个为更新状态的函数。
setXxx() 2种写法：
	setXxx(value) 赋值给xxx。
	setXxx(value=>newValue)参数为函数，接收原本的状态值，返回新的状态值，内部用其覆盖原来的状态。
	
function A(){
	// console.log(this) // undefined
	const [count,setCount] = React.useState(0)
	
  function add(){
    setCount(count++)
    // setCount(value=>value+1)
  }
  
	return (
    <div>
    	<span> { count } </span>
      <button onClick={ add }>+ 1</button>
    </div>	
	)
}
```

#### 2.Effect Hook

```
Effect Hook 可以让你在函数组件中执行副作用操作「用于模拟类组件中的声明周期钩子」
	一般用于 发ajax请求
	设置订阅/启动定时器
	手动更改真实DOM
	语法和说明
	useEffect(()=>{
		// 在此可以执行任何带副作用的操作
		return ()=>{
				//在组件卸载前执行，做一些收尾工作，比如清除定时器，取消订阅。
		}
	},[stateValue]) // 如果指定的是[],回调函数只会在第一次render() 后执行
	
	可以把useEffect Hook 是类组件的三个生命周期函数的组合
		componentDidMount() // 组件第一次渲染时就会执行
		componentDidUpdate() // 当第二个参数不传时每次都会触发，或者传入了React.useState(xx)某个值，当值变化时才会触发。
		componentWillUnmount() // 是一个参数的返回值，这里返回了一个回调函数做一些卸载出来
```

#### 3.Ref Hook

> 操作dom的hook

```
Ref Hook 可以在函数组件中存储/查找组件内的标签或任意其他数据
语法 const refContainer = React.useRef()
作用：保存标签对象，功能与React.creatRef() 一样。
```

