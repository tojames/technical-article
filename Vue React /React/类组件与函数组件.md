# 类组件与函数组件

来自react作者dan说明 https://overreacted.io/how-are-function-components-different-from-classes/

这篇文件论述了**函数组件会捕获 render 内部的状态，这是两类组件最大的不同。**

> 在不同场景使用不同的组件，才能发挥出最大的作用。
>
> 不同点
>
> - 类组件需要继承class，函数组件不需要
> - 类组件可以访问生命周期方法，函数组件不能
> - 类组件中可以获取到实例化后的this，并基于this做各种各样的事情，函数组件不能
> - 类组件中可以定义并维护state，而函数组件不可以，需要通过useState



## 类组件

> 由于类组件继承了React.component，让它一开始就拥有各种各样的属性和方法，「打印this就可以看见」。

类组件是面向对象编程思想的代表，主要有以下两点。

封装：将一类属性和方法，“聚拢”到一个 Class 里去。

继承：新的 Class 可以通过继承现有 Class，实现对某一类属性和方法的复用。

这样就会导致类组件的能力特别多，导致学习成本高，并且有时候出现组件抽离的时候，由于开发者编写的逻辑在封装后是和组件粘在一起的，这就使得类**组件内部的逻辑难以实现拆分和复用。**如果你想要打破这个僵局，则需要进一步学习更加复杂的设计模式（比如高阶组件、Render Props 等），用更高的学习成本来交换一点点编码的灵活度。

**最标准的写法**

```js
//1.创建组件
class Weather extends React.Component{
	//构造器调用几次？ ———— 1次
	constructor(props){
		super(props)
		//初始化状态
		this.state = {isHot:false,wind:'微风'}
	 //解决changeWeather中this指向问题
   // 原理：先执行右侧代码，在Weather原型上找到了changeWeather，通过绑定this，赋值给当前实例				     				// this.changeWeather创建了一个栈来接收新的函数地址，接着render就可以调用当前实例的方法了。
		this.changeWeather = this.changeWeather.bind(this)
	}

	//render调用几次？ ———— 1+n次 1是初始化的那次 n是状态更新的次数
	render(){
		console.log('render');
		//读取状态
		const {isHot,wind} = this.state
    // 这里this.changeWeather 是通过onClick的函数，所以this是丢失的，通过再次bind后就不会丢失了。
		return <h1 onClick={this.changeWeather}>今天天气很{isHot ? '炎热' : '凉爽'}，{wind}</h1>
	}

	//changeWeather调用几次？ ———— 点几次调几次
	changeWeather(){
		//由于changeWeather是作为onClick的回调，所以不是通过实例调用的，是直接调用
		//类中的方法默认开启了局部的严格模式，所以changeWeather中的this为undefined
		
		console.log('changeWeather');
		//获取原来的isHot值
		const isHot = this.state.isHot
		//严重注意：状态必须通过setState进行更新,且更新是一种合并，不是替换。
		this.setState({isHot:!isHot})
		console.log(this);

		//严重注意：状态(state)不可直接更改，下面这行就是直接更改！！！
		//this.state.isHot = !isHot //这是错误的写法
	}
}
//2.渲染组件到页面
ReactDOM.render(<Weather/>,document.getElementById('test'))
```

**开发写法**

> 开发这种写法可以为我们省下很多代码，把construcoor中的内容搬出来写。一种更加简洁的书写方式。

```js
//1.创建组件
	class Weather extends React.Component{
		//初始化状态，这就像普通的对象赋值操作一般
		state = {isHot:false,wind:'微风'}

		render(){
			const {isHot,wind} = this.state
			return <h1 onClick={this.changeWeather}>今天天气很{isHot ? '炎热' : '凉爽'}，{wind}</h1>
		}

		//自定义方法————要用赋值语句的形式+箭头函数，箭头函数去外层找this，找到初始化实例对象的 Weather 类。
		changeWeather = ()=>{
			const isHot = this.state.isHot
			this.setState({isHot:!isHot})
		}
	}
	//2.渲染组件到页面
	ReactDOM.render(<Weather/>,document.getElementById('test'))
		
```



## 函数组件

函数组件是函数式编程的代表，这种思想是和`React`是相匹配

> 轻量，学习成本低，并且可以解决很多问题。
>
> 函数组件会捕获render内部的状态，函数组件真正地把数据和渲染绑定到了一起。
>

### 函数组件重新渲染

> 函数组件的重新渲染要比类组件更难控制，并且时常重新渲染。
>
> 函数组件的重新渲染其实是函数的调用，每一次调用都是一个新的函数，变量，但是**涉及hook的变量、函数不一样，react底层做了缓存处理**。

- useState状态发生更变就会重新渲染。
- props 父组件传过来的状态发生了改变



为什么需要 React-Hooks？

```
优点
1.告别难以理解的 Class  
	主要是this 和生命周期函数这两点，如果想到还有其他也可以加上。

2.解决业务逻辑难以拆分的问题
	在生命周期中调用特别多的逻辑，复杂页面中这些代码看起来着实头疼。
	函数组件可以拆分更小的组件，可以把这些繁杂的操作按照逻辑上的关联拆分进不同的函数组件里：我们可以有专门管理订阅的函数组件、专门处理 DOM 的函数组件、专门获取数据的函数组件等。Hooks 能够帮助我们实现业务逻辑的聚合，避免复杂的组件和冗余的代码。
	其实类组件也可以啊，为什么我们不使用，因为重啊，而函数组件轻。

3.使状态逻辑复用变得简单可行；
  使用自定义Hook，Hooks 可以视作是 React 为解决状态逻辑复用这个问题所提供的一个原生途径。现在我们可以通过自定义 Hook，达到既不破坏组件结构、又能够实现逻辑复用的效果。

4.函数组件从设计思想上来看，更加契合 React 的理念。
 因为react 说过类组件和函数组件唯一不同是，函数组件会捕获render内部的状态
	
缺点
Hooks 暂时还不能完全地为函数组件补齐类组件的能力：比如 getSnapshotBeforeUpdate、componentDidCatch 这些生命周期，目前都还是强依赖类组件的。

“轻量”几乎是函数组件的基因，这可能会使它不能够很好地消化“复杂”：我们有时会在类组件中见到一些方法非常繁多的实例，如果用函数组件来解决相同的问题，业务逻辑的拆分和组织会是一个很大的挑战。我个人的感觉是，从头到尾都在“过于复杂”和“过度拆分”之间摇摆不定。耦合和内聚的边界，有时候真的很难把握，函数组件给了我们一定程度的自由，却也对开发者的水平提出了更高的要求。
```

