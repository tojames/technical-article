# 优先级

React的Concurrent模式下，不同优先级任务的存在会导致一种现象：**高优先级的任务可以打断低优先级任务的执行**。但是打断归打断，总归是要恢复低优先级任务的，于是，**低优先级任务在打断之后被恢复**。另外，倘若**低优先级任务一直被高优先级任务打断，那么低优先级任务就会过期，会被强制执行掉**。这就是我们要讨论的两个问题：**高优先级任务插队**和**饥饿问题**。



​	

```jsx
class Demo extends Component {
  constructor(props) {
    super(props);
    this.buttonRef = createRef();
  }
  state = {
    count: 0,
  };
  componentDidMount() {
    this.setState({ count: 1 });

    const button = this.buttonRef.current;
    setTimeout(
      () =>
        this.setState({ count: 1 }, () => {
          console.log("hello");
        }),
      500
    );
    setTimeout(() => button.click(), 0);
    //   A2是常规优先级的更新，A1是button.click()产生高优先级的更新。
    //   A后边的数字表示优先级，lane模型中，越小优先级越高，1 > 2。
    //   updateQueue：A2 - A1
    //                1    +2
    //   以1的优先级来执行updateQueue，发现队列中第一个update A2 比当前的渲染优先级低，跳过它处理A1
    //     Base state: 0
    //     Updates: [A1]              <-  +2
    //     Result state: 2
    //
    //   以2的优先级来执行updateQueue，队列中的update都会被处理，A1之前已经被处理过一次，所以A1会以不同的优先级处理两次
    //     Base state: 0              <-  因为上次A2被跳过了，所以base state是A2之前的状态 0
    //
    //     Updates: [A2, A1]          <-  当A1被处理的时候，A2已经处理完了，在1的基础上进行+2操作
    //               1   +2
    //     Result state: 3
  }
  handleButtonClick = () => {
    this.setState((prevState) => {
      return { count: prevState.count + 2 };
    });
  };
  render() {
    return (
      <div className={"origin-demo"}>
        <p>
          不需要点击这个按钮，这个按钮是交给js去模拟点击用的，模拟点击之后产生的是高优先级任务
        </p>
        <button ref={this.buttonRef} onClick={this.handleButtonClick}>
          增加2
        </button>
        <div>
          {Array.from(new Array(10000)).map((v, index) => (
            <div key={index}>{this.state.count}</div>
          ))}
        </div>
      </div>
    );
  }
}
```

事件优先转换成更新优先级

## 事件优先级

> 当事件触发绑定的时候，就会触发这个方法，会根据不同的事件名称来给不同的优先级

**注意：discreteUpdatesImpl 方法 在 setBatchingImplementation  方法中被替换了，见下文。**

```tsx
export function createEventListenerWrapperWithPriority(
  targetContainer: EventTarget,
  domEventName: DOMEventName,
  eventSystemFlags: EventSystemFlags,
): Function {
  // 根据事件名，通过map，得到 eventPriority
  const eventPriority = getEventPriorityForPluginSystem(domEventName);
  let listenerWrapper;
  switch (eventPriority) {
    // 1.DiscreteEvent：cancel、click、copy、doubleClick 等等，优先级最高，依次递减
    case DiscreteEvent:
      listenerWrapper = dispatchDiscreteEvent;
      break;
    // 2.UserBlockingEvent：drag、mouseMove、toggle
    case UserBlockingEvent:
      listenerWrapper = dispatchUserBlockingUpdate;
      break;
    // 3.ContinuousEvent：abort、canplay
    // 当 react 没有捕获到事件的优先级，将会以 ContinuousEvent 事件作为处理
    case ContinuousEvent:
    default:
      listenerWrapper = dispatchEvent;
      break;
  }
  return listenerWrapper.bind(null,domEventName,eventSystemFlags,targetContainer);
}

// cancel、click、copy、doubleClick 等事件触发
function dispatchDiscreteEvent(domEventName,eventSystemFlags,container,nativeEvent) {
  // dispatchEvent：触发事件函数
  // domEventName：触发事件的名字 click
  // eventSystemFlags：4
  // container：事件是挂载在容器上 <div id="root"></div> 
  // nativeEvent： 原生事件对象
  discreteUpdates( dispatchEvent, domEventName, eventSystemFlags, container,nativeEvent,);
}

export function discreteUpdates(fn, a, b, c, d) {
  const prevIsInsideEventHandler = isInsideEventHandler;
  isInsideEventHandler = true;
  try {
  // 注意这个方法，并不是 
  // let discreteUpdatesImpl = function(fn, a, b, c, d) {
  // 	return fn(a, b, c, d);
  // };
  // 它是在 setBatchingImplementation 中被替换了。
    return discreteUpdatesImpl(fn, a, b, c, d);
  } finally {
    isInsideEventHandler = prevIsInsideEventHandler;
    if (!isInsideEventHandler) {
      finishEventHandler();
    }
  }
}

export function discreteUpdates(fn,a,b,c,d){ 
    try {
      return runWithPriority(
        UserBlockingSchedulerPriority,
        fn.bind(null, a, b, c, d),
      );
    } finally {
      executionContext = prevExecutionContext;
      if (executionContext === NoContext) {
        // Flush the immediate callbacks that were scheduled during this batch
        resetRenderTimer();
        flushSyncCallbackQueue();
      }
    }
  }
}

路径：/packages/react-reconciler/src/SchedulerWithReactIntegration.old.js
export function runWithPriority<T>( reactPriorityLevel: ReactPriorityLevel, fn: () => T,): T {
  const priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel);
  return Scheduler_runWithPriority(priorityLevel, fn);
}


function reactPriorityToSchedulerPriority(reactPriorityLevel) {
  switch (reactPriorityLevel) {
    case ImmediatePriority:
      return Scheduler_ImmediatePriority;
    case UserBlockingPriority:
      return Scheduler_UserBlockingPriority;
    case NormalPriority:
      return Scheduler_NormalPriority;
    case LowPriority:
      return Scheduler_LowPriority;
    case IdlePriority:
      return Scheduler_IdlePriority;
    default:
      invariant(false, 'Unknown priority level.');
  }
}
对应的优先级如下
export const Scheduler_ImmediatePriority = 1;
export const Scheduler_UserBlockingPriority = 2;
export const Scheduler_NormalPriority = 3;
export const Scheduler_LowPriority = 4;
export const Scheduler_IdlePriority = 5;


function unstable_runWithPriority(priorityLevel, eventHandler) {
  switch (priorityLevel) {
    case ImmediatePriority:
    case UserBlockingPriority:
    case NormalPriority:
    case LowPriority:
    case IdlePriority:
      break;
    default:
      priorityLevel = NormalPriority;
  }

  var previousPriorityLevel = currentPriorityLevel;
  // 事件优先级存在 /packages/scheduler/src/Scheduler.js，用于调用方法的使用调用
  currentPriorityLevel = priorityLevel;

  try {
    return eventHandler();
  } finally {
    currentPriorityLevel = previousPriorityLevel;
  }
}

// 三类事件，触发都是通过这个方法，绑定参数
export function dispatchEvent(
  domEventName: DOMEventName,
  eventSystemFlags: EventSystemFlags,
  targetContainer: EventTarget,
  nativeEvent: AnyNativeEvent,
): void {
  // 通过事件系统触发方法
  const blockedOn = attemptToDispatchEvent(
    domEventName,
    eventSystemFlags,
    targetContainer,
    nativeEvent,
  );
  // 触发成功
  if (blockedOn === null) {
    // We successfully dispatched this event.
    if (allowReplay) {
      // 清除事件的副作用
      clearIfContinuousEvent(domEventName, nativeEvent);
    }
    return;
  }
  // 省略其他代码
}
```

## 更新优先级

当更新状态的时候，使用State，以setState为例。主要 `enqueueSetState` 里面的逻辑。

```tsx
const classComponentUpdater = {
  enqueueSetState(inst, payload, callback) {
    const fiber = getInstance(inst);
    const eventTime = requestEventTime();
    // 获取优先级
    const lane = requestUpdateLane(fiber);

    const update = createUpdate(eventTime, lane);
    update.payload = payload;
    if (callback !== undefined && callback !== null) {
      if (__DEV__) {
        warnOnInvalidCallback(callback, 'setState');
      }
      update.callback = callback;
    }
    // 处理更新队列
    enqueueUpdate(fiber, update);
    // 调度更新，从 render 阶段开始
    scheduleUpdateOnFiber(fiber, lane, eventTime);

    if (__DEV__) {
      if (enableDebugTracing) {
        if (fiber.mode & DebugTracingMode) {
          const name = getComponentName(fiber.type) || 'Unknown';
          logStateUpdateScheduled(name, lane, payload);
        }
      }
    }

    if (enableSchedulingProfiler) {
      markStateUpdateScheduled(fiber, lane);
    }
  }
  // 省略部分代码...
}
```

