# ReactDOM.render



## Demo

> è¿™ä¸ªä¾‹å­å°†ä¼šå›´ç»•è¿™ä¸ªdemoæ¥ä»£å…¥ç†è§£ReactDOM.renderæ•´ä¸ªæµç¨‹ã€‚

```tsx
function App() {
  const [count, setCount] = useState(0)

  return (
    <div>
       <h2> è¿™æ˜¯å­èŠ‚ç‚¹ </h2>
      <p>
        <span> è¿™æ˜¯å­™èŠ‚ç‚¹ </span>
      </p>
    </div>
  )
}

ReactDOM.render(<App />, document.getElementById("root"))


é¡ºä¾¿è¯´ä¸€ä¸‹ï¼Œ<App /> å…¶å®ä¼šç»è¿‡ babel-preset-react-app å°† jsx è½¬åŒ–ä¸º React.createElement()ï¼Œè¿›è€Œè¾“å‡º ReactElement æˆ–è€…å«åšè™šæ‹ŸDOMã€‚
```



## ReactDOM.render çš„ è°ƒç”¨æ ˆ

<img src="images/image-20220307094915116.png" alt="image-20220307094915116" style="zoom:50%;" />



## æœ€ç»ˆçš„è¿”å›ç»“æœ

![image-20220312231353066](images/image-20220312231353066.png)



## æºç è§£æ

> React çš„å‡½æ•°è°ƒç”¨æ ˆæ˜¯éå¸¸æ·±çš„ï¼Œä¸€æ­¥æ­¥ç†è§£ä¸‹å»æ‰ä¸ä¼šä¹±ã€‚å¾ˆå¤šäººéƒ½æ¨èåªçœ‹æ–¹æ³•åï¼Œä¸çœ‹é‡Œé¢çš„é€»è¾‘ï¼Œæˆ‘è§‰å¾—æœ‰äº›æ¬ å¦¥çš„ã€‚
>
> å› ä¸ºæœ‰äº›æ–¹æ³•ä¸é‡è¦ç¡®å®å¯ä»¥è¿™ä¹ˆæ“ä½œï¼Œä½†æ˜¯ä¹Ÿæœ‰å¾ˆå¤šå¾ˆé‡è¦çš„æ–¹æ³•éœ€è¦è¯¦ç»†å»ç†è§£çš„ï¼Œæ‰€ä»¥åº”è¯¥æ‰¾åˆ°è‡ªå·±æƒ³çœ‹çš„é€»è¾‘æ‰æ˜¯é‡è¦çš„ã€‚



### åˆå§‹åŒ–é˜¶æ®µ

####  å…¥å£æ–‡ä»¶ ReactDOM.render

> ä»è°ƒç”¨æ ˆä¸­å‘ç° react-dom è°ƒç”¨çš„èµ·å§‹ä½ç½®æ˜¯ `/packages/react-dom/src/client/index.js` --> `/packages/react-dom/src/client/ReactDOM.js` --> `src/react/packages/react-dom/src/client/ReactDOMLegacy.js`  æ‰¾åˆ°renderæ–¹æ³•

```tsx
// renderä½œç”¨ï¼šè¿”å› legacyRenderSubtreeIntoContainer å‡½æ•°
export function render(element: React$Element<any>,container: Container,callback: ?Function) {
  // åˆ¤æ–­å®¹å™¨æ˜¯å¦åˆæ³•ï¼Œ<div id='root'></div>,
  invariant( isValidContainer(container),'Target container is not a DOM element.');
  // çœç•¥éé‡è¦ä»£ç ...
  return legacyRenderSubtreeIntoContainer(null,element,container,false, callback);
}


// legacyRenderSubtreeIntoContainerä½œç”¨ï¼šå¹²æ´»çš„å‡½æ•°ï¼Œä½œç”¨åœ¨æ³¨é‡Šé‡Œé¢
function legacyRenderSubtreeIntoContainer(
  parentComponent: ?React$Component<any, any>, // null
  children: ReactNodeList, // <App/>
  container: Container, // domï¼Œ<div id=root></div>
  forceHydrate: boolean, // false,åˆ¤æ–­æ˜¯å¦ä¸ºæœåŠ¡ç«¯æ¸²æŸ“
  callback: ?Function, // ç»„ä»¶æ¸²æŸ“å®Œæˆçš„å›è°ƒå‡½æ•°ï¼Œä¹Ÿå°±æ˜¯ReactDOM.renderçš„ç¬¬ä¸‰ä¸ªå‚æ•°
) {
  let root: RootType = (container._reactRootContainer: any); // åˆå§‹åŒ–root
  // TODO: fiberçš„æ ¹èŠ‚ç‚¹ï¼Œç‰¹åˆ«é‡è¦
  let fiberRoot;
  // åˆå§‹åŒ–çš„æ—¶å€™ root æ˜¯ undefinedã€‚
  if (!root) {
    // è¿™é‡Œåˆå§‹åŒ–äº† ä»¥åŠå…¨å±€æ ¹èŠ‚ç‚¹fiberRootNodeï¼ŒfiberèŠ‚ç‚¹ fiberNodeï¼Œä»¥åŠäº‹ä»¶åˆå§‹åŒ–å¤„ç†ç­‰ç­‰ã€‚
    // ä¸‹é¢ä¼šæŠŠ legacyCreateRootFromDOMContainer å•ç‹¬æ‹å‡ºæ¥è®²
    root = container._reactRootContainer = legacyCreateRootFromDOMContainer( container, forceHydrate);
    fiberRoot = root._internalRoot;
    // å¤„ç†å›è°ƒå‡½æ•°
    if (typeof callback === 'function') {
      const originalCallback = callback;
      callback = function() {
        const instance = getPublicRootInstance(fiberRoot);
        originalCallback.call(instance);
      };
    }
    // Initial mount should not be batched.
   	// å½“è°ƒç”¨ unbatchedUpdates çš„æ—¶å€™å°±ä¼šè°ƒç”¨è¿™ä¸ª updateContainerï¼Œå»åˆ° Reconciler ä¸­å¤„ç†æ›´æ–°ä¼˜å…ˆçº§ï¼Œæ›´æ–°é˜Ÿåˆ—ç­‰ç­‰é—®é¢˜ã€‚
   	// ä¸‹é¢ä¼šæŠŠunbatchedUpdatesï¼ŒupdateContainer å•ç‹¬æ‹å‡ºæ¥è®²
    unbatchedUpdates(() => {
      updateContainer(children, fiberRoot, parentComponent, callback);
    });
  } else {
    // è¿™é‡Œæ˜¯æ›´æ–°é€»è¾‘ï¼Œé€»è¾‘å¤„ç†çš„æ˜¯éé¦–æ¬¡æ¸²æŸ“çš„æƒ…å†µï¼ˆå³æ›´æ–°ï¼‰ï¼Œå…¶é€»è¾‘é™¤äº†è·³è¿‡äº†åˆå§‹åŒ–å·¥ä½œï¼Œå…¶ä»–ä¸ä¸Šé¢åŸºæœ¬ä¸€è‡´
    fiberRoot = root._internalRoot;
    if (typeof callback === 'function') {
      const originalCallback = callback;
      callback = function() {
        const instance = getPublicRootInstance(fiberRoot);
        originalCallback.call(instance);
      };
    }
    // Update
    updateContainer(children, fiberRoot, parentComponent, callback);
  }
  // æœ€å
  // è¿”å›å½“å‰fiberRootçš„stateNodeï¼Œæœ‰ä¸‰ç§ç‰¹æ®Šæƒ…å†µ
  // 1.å¯¹äºFiberNode.currentæŒ‡å‘çš„FiberNodeï¼ŒstateNode ä¸º FiberRootNode
  // 2.FiberNode ä¸‹é¢çš„ App ç»„ä»¶ä¸­çš„ stateNode ä¸º null
  // 3.Appç»„ä»¶ä¸‹é¢ï¼Œå¯¹äºæ‹¥æœ‰çœŸå®domèŠ‚ç‚¹çš„èŠ‚ç‚¹ä¸­çš„ stateNode ä¸º domçœŸå®èŠ‚ç‚¹ï¼Œè¿™ä¸ªæœ€é‡è¦
  return getPublicRootInstance(fiberRoot);
}
```



#### legacyCreateRootFromDOMContainer

> åˆ›å»º`fiberRootNode` ã€ `fiberNode` çš„å…¥å£ã€‚åœ¨ `/packages/react-dom/src/client/ReactDOMLegacy.js`

```tsx
// legacyCreateRootFromDOMContainerä½œç”¨ï¼šåˆ¤æ–­æµè§ˆå™¨å’ŒæœåŠ¡ç«¯ï¼ŒéæœåŠ¡ç«¯æ¸…ç©ºå†…å®¹ï¼Œè°ƒç”¨createLegacyRoot(containerï¼Œundefined)ï¼Œå»åˆ›å»º _internalRootå¯¹è±¡
function legacyCreateRootFromDOMContainer( container: Container, forceHydrate: boolean,): RootType {
  const shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container); // æœåŠ¡ç«¯æ ‡è¯† false
  // æ¸…ç©ºå†…å®¹ <div id="root"><span>æˆ‘è¿™ä¸ªæ ‡ç­¾ä¼šè¢«æ¸…ç©ºçš„<span></div>
  // è¿™é‡Œå¯ä»¥è€ƒè™‘åšä¸€ä¸ªé¦–å±ä¼˜åŒ–ï¼Œå½“é¡µé¢è¿›æ¥çš„æ—¶å€™ï¼Œhtmlæ¸²æŸ“å ä½ loaddingï¼Œreactæ‰§è¡Œåˆ°è¿™é‡Œåå°±ä¼šæ¸…ç©ºã€‚
  if (!shouldHydrate) {
    let warned = false;
    let rootSibling;
    while ((rootSibling = container.lastChild)) {
      container.removeChild(rootSibling);
    }
  }
  //  åˆæ˜¯è¿”å›ä¸€ä¸ªæ‰§è¡Œå‡½æ•°
  return createLegacyRoot( container, shouldHydrate ? { hydrate: true, }  : undefined );
}

/packages/react-dom/src/client/ReactDOMRoot.js
export function createLegacyRoot(
	container: Container, // container
  options?: RootOptions, // undefined
): RootType {
  // LegacyRoot: 0,æ‰§è¡Œæ„é€ å‡½æ•° ReactDOMBlockingRoot
  return new ReactDOMBlockingRoot(container, LegacyRoot, options);
  // ReactDOMBlockingRootçš„æ–¹æ³•ä½“ï¼Œ this._internalRoot = createRootImpl(container, tag, options);
}

// åˆ›å»º _internalRoot çš„æ–¹æ³•ã€‚
function createRootImpl(
  container: Container,
  tag: RootTag, // 0
  options: void | RootOptions, // defined
) {
	// åˆ›å»ºfiberRootNode,	ä¸‹é¢å°†ä¼šå±•å¼€
  const root = createContainer(container, tag, false, null);
  // äº‹ä»¶ç³»ç»Ÿï¼Œå¿½ç•¥, export const enableEagerRootListeners = true
  if (enableEagerRootListeners) {
    // container.nodeType:1
    // COMMENT_NODE:8
    const rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
    listenToAllSupportedEvents(rootContainerElement);
  } 
  // æŠŠåˆšåˆšåˆ›å»ºçš„fiberRootNodeè¿”å›
  return root;
}
```

#### åˆ›å»ºFiberRootNode

> ç”±ä¸Šé¢çŸ¥é“ è°ƒç”¨äº† `createContainer`ï¼Œè¿™æ—¶å€™æ˜¯å»åˆ°ï¼Œ`/packages/react-reconciler/src/ReactFiberReconciler.js`
> éœ€è¦ä½¿ç”¨oldç‰ˆæœ¬ï¼Œæ‰¾åˆ° createContainer_old ï¼Œ `/packages/react-reconciler/src/ReactFiberReconciler.old.js`ã€‚

**æ³¨æ„ï¼šenableNewReconcileræ˜¯ç”¨æ¥åŒºåˆ†ä½¿ç”¨ æ–‡ä»¶åç¼€æ˜¯newè¿˜æ˜¯oldï¼Œç”±äºReactç°åœ¨é»˜è®¤éƒ½æ˜¯ä½¿ç”¨oldï¼Œå®ƒè®¾ç½®è¿™ä¸ªçš„åŸå› æ˜¯ä¸ºäº†æ–°çš„ç‰ˆæœ¬å’Œå½“å‰ç‰ˆæœ¬å¯ä»¥åŒæ—¶æ¨è¿›ï¼Œä½†æ˜¯æ‰“tagä¸èƒ½æ»¡è¶³é€»è¾‘æ”¹åŠ¨å¤ªå¤§ï¼Œæ‰€ä»¥å°±é‡‡ç”¨äº†ä½¿ç”¨æ–‡ä»¶åšä»¥åŒºåˆ†**

```tsx
export function createContainer(
  containerInfo: Container,
  tag: RootTag,
  hydrate: boolean,
  hydrationCallbacks: null | SuspenseHydrationCallbacks,
): OpaqueRoot {
  // è¿”å›åˆ›å»º fiberRootNode
  return createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks);
}

export function createFiberRoot(
  containerInfo: any, // <div id='root'><div>
  tag: RootTag, // 0
  hydrate: boolean, // false
  hydrationCallbacks: null | SuspenseHydrationCallbacks, // null
): FiberRoot {
  // TODO: åˆ›å»ºFiberRootNodeèŠ‚ç‚¹ï¼Œä¸‹é¢å±•å¼€ã€‚
  const root: FiberRoot = (new FiberRootNode(containerInfo, tag, hydrate): any);

  // åˆ›å»º FiberNodeèŠ‚ç‚¹, ä¸‹é¢å±•å¼€ã€‚
  const uninitializedFiber = createHostRootFiber(tag);
  // è¿™é‡Œæœ‰ä¸€ä¸ªå¾ªç¯å¼•ç”¨ï¼Œä»è¿™é‡Œçœ‹å‡ºæ¥ FiberRootNode å’Œ  FiberNodeèŠ‚ç‚¹ çš„å…³ç³»
  root.current = uninitializedFiber;
  uninitializedFiber.stateNode = root;

  // åˆå§‹åŒ–æ›´æ–°é“¾è¡¨
  initializeUpdateQueue(uninitializedFiber);

  return root;
}
```

###### FiberRootNode

> åœ¨è¿™é‡Œæ‰æ˜¯çœŸçš„åˆ›å»º `fiberRootNode` ğŸ˜‚ , `packages/react-reconciler/src/ReactFiberRoot.old.js`

```tsx
function FiberRootNode(containerInfo, tag, hydrate) {
  this.tag = tag; // 0
  this.hydrate = hydrate; // false
  this.containerInfo = containerInfo; //  <div id='root'></div>
  // The currently active root fiber. This is the mutable root of the tree.
  // å½“å‰åº”ç”¨rootèŠ‚ç‚¹å¯¹åº”çš„Fiberå¯¹è±¡ï¼Œå³Root Fiberï¼ŒReactElementä¼šæœ‰ä¸€ä¸ªæ ‘ç»“æ„ï¼ŒåŒæ—¶ä¸€ä¸ªReactElementå¯¹åº”ä¸€ä¸ªFiberå¯¹è±¡ï¼Œæ‰€ä»¥Fiberä¹Ÿä¼šæœ‰æ ‘ç»“æ„
  this.pendingChildren = null; 
  this.current = null; // fiberNodeï¼Œè¿™é‡Œæ˜¯ç¬¬ä¸€ä¸ªfiberçš„èµ·ç‚¹ï¼Œå³æ˜¯appç»„ä»¶çš„çˆ¶äº²
  // WeakMap<Wakeable, Set<mixed>> | Map<Wakeable, Set<mixed>> | null,
  // ä»»åŠ¡æœ‰ä¸‰ç§ï¼Œä¼˜å…ˆçº§æœ‰é«˜ä½ï¼š
  // 1.æ²¡æœ‰æäº¤çš„ä»»åŠ¡
  // 2.æ²¡æœ‰æäº¤çš„è¢«æŒ‚èµ·çš„ä»»åŠ¡
  // 3.æ²¡æœ‰æäº¤çš„å¯èƒ½è¢«æŒ‚èµ·çš„ä»»åŠ¡
  this.pingCache = null;
  // A finished work-in-progress HostRoot that's ready to be committed.
  // å·²ç»å®Œæˆä»»åŠ¡çš„FiberRootå¯¹è±¡ï¼Œå¦‚æœä½ åªæœ‰ä¸€ä¸ªRootï¼Œé‚£ä¹ˆè¯¥å¯¹è±¡å°±æ˜¯è¿™ä¸ªRootå¯¹åº”çš„Fiberæˆ–null
  // åœ¨commit(æäº¤)é˜¶æ®µåªä¼šå¤„ç†è¯¥å€¼å¯¹åº”çš„ä»»åŠ¡
  this.finishedWork = null;  
  // Timeout handle returned by setTimeout. Used to cancel a pending timeout, if it's superseded by a new one.
  // export const noTimeout = -1;
  // åœ¨ä»»åŠ¡è¢«æŒ‚èµ·çš„æ—¶å€™ï¼Œé€šè¿‡setTimeoutè®¾ç½®çš„å“åº”å†…å®¹ï¼Œ
  // å¹¶ä¸”æ¸…ç†ä¹‹å‰æŒ‚èµ·çš„ä»»åŠ¡ è¿˜æ²¡è§¦å‘çš„timeout
  this.timeoutHandle = noTimeout;
  // é¡¶å±‚contextå¯¹è±¡ï¼Œåªæœ‰ä¸»åŠ¨è°ƒç”¨renderSubtreeIntoContaineræ‰ä¼šç”Ÿæ•ˆ
  // context: Object | null,
  this.context = null;
  this.pendingContext = null; // æœåŠ¡ç«¯ç›¸å…³
  // Node returned by Scheduler.scheduleCallback. Represents the next rendering
  // task that the root will work on.
  this.callbackNode = null;
  // é»˜è®¤æ˜¯æœ€é«˜çº§çš„å›è°ƒå‡½æ•°
  this.callbackPriority = NoLanePriority;
  this.eventTimes = createLaneMap(NoLanes);
  this.expirationTimes = createLaneMap(NoTimestamp);

  // è¿™é‡Œçš„ä¼˜å…ˆçº§å…¨æ˜¯æœ€é«˜çº§,åœ¨å¤„ç†ä¸åŒä¼˜å…ˆçº§çš„æ—¶å€™ï¼Œè¿™é‡Œçš„å€¼éƒ½ä¼šä¸€ç›´å˜åŒ–
  this.pendingLanes = NoLanes;
  this.suspendedLanes = NoLanes;
  this.pingedLanes = NoLanes;
  this.expiredLanes = NoLanes;
  this.mutableReadLanes = NoLanes;
  this.finishedLanes = NoLanes;

  this.entangledLanes = NoLanes;
  this.entanglements = createLaneMap(NoLanes);
  // æœåŠ¡ç«¯ç›¸å…³
  if (supportsHydration) {
    this.mutableSourceEagerHydrationData = null;
  }

  // The following attributes are only used by interaction tracing builds.
  // They enable interactions to be associated with their async work,
  // And expose interaction metadata to the React DevTools Profiler plugin.
  // Note that these attributes are only defined when the enableSchedulerTracing flag is enabled.
  if (enableSchedulerTracing) {
    this.interactionThreadID = unstable_getThreadID();
    this.memoizedInteractions = new Set();
    this.pendingInteractionMap = new Map();
  }
  // false
  if (enableSuspenseCallback) {
    this.hydrationCallbacks = null;
  }
}
```

###### FiberNode

> åœ¨è¿™é‡Œæ‰æ˜¯çœŸçš„åˆ›å»º `fiberNode` ğŸ˜‚ , `packages/react-reconciler/src/ReactFiberRoot.old.js`

```tsx
export function createHostRootFiber(tag: RootTag): Fiber {
  let mode;
  if (tag === ConcurrentRoot) {
    mode = ConcurrentMode | BlockingMode | StrictMode;
  } else if (tag === BlockingRoot) {
    mode = BlockingMode | StrictMode;
  } else {
    // åˆå§‹åŒ–ä¼šå¾—åˆ°0
    mode = NoMode;
  }
  
  if (enableProfilerTimer && isDevToolsPresent) {
    // Always collect profile timings when DevTools are present.
    // This enables DevTools to start capturing timing at any pointâ€“
    // Without some nodes in the tree having empty base times.
    mode |= ProfileMode; // 8
  }
  // HostRoot:3,mode:8
  return createFiber(HostRoot, null, null, mode);
}

packages/react-reconciler/src/ReactFiber.old.js
const createFiber = function(
  tag: WorkTag,
  pendingProps: mixed,
  key: null | string,
  mode: TypeOfMode,
): Fiber {
  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors
  return new FiberNode(tag, pendingProps, key, mode);
};



// åˆ›å»ºfiberèŠ‚ç‚¹
function FiberNode(
  tag: WorkTag, 
  pendingProps: mixed, 
  key: null | string,
  mode: TypeOfMode, 
) {
  // Instance
  this.tag = tag; // å®šfiberçš„ç±»å‹ã€‚åœ¨reconciliationç®—æ³•ä¸­ä½¿ç”¨å®ƒæ¥ç¡®å®šéœ€è¦å®Œæˆçš„å·¥ä½œ
  this.key = key; // å”¯ä¸€æ ‡è¯†ç¬¦
  this.elementType = null;
  this.type = null; // å®šä¹‰ä¸fiberå…³è”çš„åŠŸèƒ½æˆ–ç±»ã€‚å¯¹äºç±»ç»„ä»¶ï¼Œå®ƒæŒ‡å‘æ„é€ å‡½æ•°ï¼Œå¯¹äºDOMå…ƒç´ ï¼Œå®ƒæŒ‡å®šHTMLæ ‡è®°ã€‚æˆ‘ç»å¸¸ä½¿ç”¨æ­¤å­—æ®µæ¥äº†è§£å…‰çº¤èŠ‚ç‚¹ä¸å“ªäº›å…ƒç´ ç›¸å…³ã€‚
  this.stateNode = null; // ä¸€èˆ¬è§†ä¸ºçœŸå®èŠ‚ç‚¹ï¼ŒåŠæ—¶æœ‰æ—¶å€™ä¸æ˜¯

  // Fiber
  this.return = null; // æŒ‡å‘çˆ¶èŠ‚ç‚¹
  this.child = null; // æŒ‡å‘å­èŠ‚ç‚¹
  this.sibling = null; // æŒ‡å‘å…„å¼ŸèŠ‚ç‚¹
  this.index = 0; // åœ¨è¿™ä¹ˆå¤šå…„å¼Ÿä¸­æ’è¡Œç¬¬å‡ 

  this.ref = null; // æ“ä½œdomçš„æ–¹æ³•

  this.pendingProps = pendingProps; // æ–°çš„å˜åŠ¨å¸¦æ¥çš„æ–°çš„propsï¼Œå³nextPropsã€‚
  this.memoizedProps = null; // ä¸Šä¸€æ¬¡è¾“å…¥æ›´æ–°çš„Fiber props
  this.updateQueue = null; // çŠ¶æ€æ›´æ–°ï¼Œå›è°ƒå’ŒDOMæ›´æ–°çš„é˜Ÿåˆ—ï¼ŒFiberå¯¹åº”çš„ç»„ä»¶ï¼Œæ‰€äº§ç”Ÿçš„updateï¼Œéƒ½ä¼šæ”¾åœ¨è¯¥é˜Ÿåˆ—ä¸­
  this.memoizedState = null; // å­˜æ”¾ hooksé“¾è¡¨
  this.dependencies = null; // ä¸€ä¸ªåˆ—è¡¨ï¼Œå­˜åœ¨è¯¥Fiberä¾èµ–çš„contextsï¼Œevents

  this.mode = mode;  // æ¨¡å¼ï¼Œç»§æ‰¿çˆ¶fiber

  // Effects
  this.flags = NoFlags; // å½“å‰fiberé˜¶æ®µéœ€è¦è¿›è¡Œä»»åŠ¡ï¼ŒåŒ…æ‹¬ï¼šå ä½ã€æ›´æ–°ã€åˆ é™¤ç­‰ï¼Œä¸€èˆ¬å‘ç”Ÿåœ¨diffçš„æ—¶å€™æ‰“ä¸Šæ ‡è®°
  this.nextEffect = null; // è®°å½•å‰¯ä½œç”¨

  this.firstEffect = null; // åŒä¸Š
  this.lastEffect = null; // åŒä¸Š

  this.lanes = NoLanes; // ä¼˜å…ˆçº§
  this.childLanes = NoLanes; // childä¼˜å…ˆçº§

  // double buffer
  this.alternate = null; // current fiberæŒ‡å‘work in progress fiber;working in progress fiberæŒ‡å‘current fiber
  // enableProfilerTimerï¼štrue
  if (enableProfilerTimer) {
    // æ³¨æ„ï¼šè¿™é‡Œä¸ºä»€ä¹ˆä¼šå‡ºç°èµ‹å€¼ä¸¤æ¬¡å‘¢ï¼Œè¿™ä¸ªé—®é¢˜å‚è€ƒä¸‹é¢çš„é“¾æ¥ï¼Œæˆ‘çš„ç†è§£æ˜¯ï¼ŒgetHostSiblingæ–¹æ³•ä½¿ç”¨åˆ°è¿™äº›å˜é‡çš„æ—¶å€™ï¼Œä¼šç¼“æ…¢ï¼Œè¿™å¯¹äºchromeæ¥è¯´ä¹Ÿæ˜¯ä¸€ç§å¥‡æ€ªçš„è¡Œä¸ºï¼Œä½†æ˜¯è§£å†³çš„æ–¹å¼æ˜¯å…ˆèµ‹å€¼  Number.NaN æˆ– Number.MIN_VALUEæ‰èµ‹ä¸ŠçœŸæ­£çš„å€¼ï¼Œå€¼å¾—ä¸€æçš„æ˜¯è¿™æ˜¯18å¹´åˆæå‡ºçš„é—®é¢˜ï¼Œåˆ°ç°åœ¨éƒ½è¿˜æ²¡è§£å†³ã€‚
    // https://github.com/facebook/react/issues/14365
    // https://bugs.chromium.org/p/v8/issues/detail?id=8538
    this.actualDuration = Number.NaN;
    this.actualStartTime = Number.NaN;
    this.selfBaseDuration = Number.NaN;
    this.treeBaseDuration = Number.NaN;
    this.actualDuration = 0;
    this.actualStartTime = -1;
    this.selfBaseDuration = 0;
    this.treeBaseDuration = 0;
  }
}
```

è‡³æ­¤ï¼Œåˆå§‹åŒ–çš„fiberå·²ç»åˆ›å»ºå®Œæ¯•ï¼Œå®ƒä»¬å…³ç³»å¦‚ä¸‹ã€‚

<img src="images/image-20220303092849995.png" alt="image-20220303092849995" style="zoom:50%;" />





#### unbatchedUpdatesï¼ŒupdateContainer

> fiberåˆå§‹åŒ–åï¼Œå›åˆ° `ReactDOMLegacy`ï¼Œ`/packages/react-dom/src/client/ReactDOMLegacy.js` æ‰¾åˆ° `legacyRenderSubtreeIntoContainer` æ–¹æ³•,å°†ä¼šå»åˆ°Reconcileræ–‡ä»¶å¤¹ä¸­ã€‚ `/packages/react-reconciler/src/ReactFiberReconciler.old.js`
> 

```tsx
unbatchedUpdates(() => {
    updateContainer(children, fiberRoot, parentComponent, callback);
});

export function unbatchedUpdates<A, R>(fn: (a: A) => R, a: A): R {
  // å¯¹ä¸Šä¸‹æ–‡å¤„ç†
  const prevExecutionContext = executionContext;
  executionContext &= ~BatchedContext;
  executionContext |= LegacyUnbatchedContext;
  try {
    // ç›´æ¥è°ƒç”¨äº†ä¼ å…¥çš„å›è°ƒå‡½æ•° fnï¼Œä¹Ÿå°±æ˜¯updateContainer
    return fn(a);
  } finally {
    // å°†ä¸Šä¸‹æ–‡å¤åŸ
    executionContext = prevExecutionContext;
    if (executionContext === NoContext) {
      // Flush the immediate callbacks that were scheduled during this batch
      resetRenderTimer(); // è®¾ç½®æ—¶é—´  === workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;
      // åˆ·æ–°å›è°ƒ
      flushSyncCallbackQueue(); 
    }
  }
}

export function updateContainer(
  element: ReactNodeList, // <App/>
  container: OpaqueRoot, // FiberRootNode
  parentComponent: ?React$Component<any, any>, // null
  callback: ?Function, // undefined
): Lane {
  const current = container.current; // è·å–fiberNode
  const eventTime = requestEventTime(); // å½“å‰æ—¶é—´
  // æ˜¯ä¸€ä¸ªå®šä¹‰ä¼˜å…ˆçº§æ¨¡å‹ï¼Œè¿™é‡Œæ˜¯é€šè¿‡å„ç§åˆ¤æ–­åï¼Œè¿”å›lane
  const lane = requestUpdateLane(current); // 1

  // åˆ›å»º update å¯¹è±¡ï¼Œä¸€ä¸ª update å¯¹è±¡ä»£è¡¨ç€ä¸€ä¸ªæ›´æ–°
  const update = createUpdate(eventTime, lane);
  /* 
    callback: null,
    eventTime: 782.8000000007451,
    lane: 1,
    next: null,
    payload:
    element: {$$typeof: Symbol(react.element), key: null, ref: null, props: {â€¦}, type: Æ’, â€¦},
    tag: 0
  */

  // Caution: React DevTools currently depends on this property
  // being called "element".
  update.payload = {element};

  // React.render(x,y,cb),ä¸­çš„å›è°ƒå‡½æ•°
  callback = callback === undefined ? null : callback;
  if (callback !== null) {
    if (__DEV__) {
      if (typeof callback !== 'function') {
        console.error(
          'render(...): Expected the last optional `callback` argument to be a ' +
            'function. Instead received: %s.',
          callback,
        );
      }
    }
    update.callback = callback;
  }
   // æ›´æ–°é“¾è¡¨ï¼Œæ˜¯updateæ”¾åœ¨å‰é¢
  enqueueUpdate(current, update);
  
  // è°ƒåº¦èŠ‚ç‚¹ï¼ŒcurrentèŠ‚ç‚¹å³ fiberNodeï¼Œå¼€å¯renderé˜¶æ®µï¼Œä¸‹é¢ä¼šå±•å¼€ã€‚
  scheduleUpdateOnFiber(current, lane, eventTime);
  return lane;
}
```

#### å°ç»“

ç»¼ä¸Šï¼Œå°±æ˜¯å¤§æ¦‚`React` åˆå§‹åŒ–é˜¶æ®µåšäº†ä»€ä¹ˆäº‹æƒ…ï¼Œä¸»è¦åˆå§‹åŒ–ä¸€ä¸‹fiberä¿¡æ¯ï¼Œä»¥åŠåç»­éœ€è¦ç”¨åˆ°çš„å„ç§å­—æ®µï¼Œäº‹ä»¶ç­‰ç­‰ã€‚



### Render é˜¶æ®µ 



#### scheduleUpdateOnFiber

> `scheduleUpdateOnFiber` å³æ˜¯è¿›å…¥renderé˜¶æ®µçš„æ ‡å¿—ï¼Œ`/packages/react-reconciler/src/ReactFiberWorkLoop.old.js`

```tsx
export function scheduleUpdateOnFiber(
  fiber: Fiber,
  lane: Lane,
  eventTime: number,
) {
	// åˆ é™¤äº†ä¸å½±å“é˜…è¯»ä»£ç 
  // React æœ‰ä¸‰ç§æ¨¡å¼ï¼šlegacy æ¨¡å¼ã€ŒåŒæ­¥ã€ï¼Œ blocking æ¨¡å¼ã€Œè¿‡æ¸¡ã€ï¼Œconcurrent æ¨¡å¼ã€Œå¼‚æ­¥ã€
  // è¿™é‡Œæ˜¯åŒæ­¥æ¸²æŸ“çš„é€»è¾‘ legacy æ¨¡å¼ï¼Œlane === SyncLane === true
  if (lane === SyncLane) {
      // è¿™ä¸­é—´åŒ…å«äº†å¤§é‡çš„ beginWorkã€completeWork è°ƒç”¨æ ˆï¼Œæ­£æ˜¯ render çš„å·¥ä½œå†…å®¹ã€‚
      performSyncWorkOnRoot(root);
  } 
  // concurrent æ¨¡å¼ï¼šå¼‚æ­¥æ›´æ–°
  else {
   ...
  }
  mostRecentlyUpdatedRoot = root;
}

// root:fiberRootNode
function performSyncWorkOnRoot(root) {
  let lanes;
  let exitStatus;
  /* 
  export function includesSomeLane(a: Lanes | Lane, b: Lanes | Lane) {
    return (a & b) !== NoLanes;
  }
  */
  // è¿™é‡Œä¼šè¿”å›false
  if (root === workInProgressRoot && includesSomeLane(root.expiredLanes, workInProgressRootRenderLanes) ) {
    ....
  } else {
    // NoLanes 0
    // è·å–ä¸‹ä¸€ä¸ªä¼˜å…ˆçº§
    lanes = getNextLanes(root, NoLanes); // 1
    // æ ¸å¿ƒæ–¹æ³•æ˜¯è¿™ä¸ªï¼Œä¸‹é¢ä¼šå±•å¼€
    exitStatus = renderRootSync(root, lanes); // 5

  }

  // å¾—åˆ° workInProgress æ ‘
  const finishedWork: Fiber = (root.current.alternate: any);
  root.finishedWork = finishedWork;
  root.finishedLanes = lanes;
  
  // å¼€å¯æäº¤é˜¶æ®µï¼Œä¸‹é¢ä¼šå±•å¼€ã€‚
  commitRoot(root);
}


function renderRootSync(root: FiberRoot, lanes: Lanes) {
  const prevExecutionContext = executionContext;
  executionContext |= RenderContext;
  // å¤§é‡çš„hooksé¢„å¤„ç†çš„ä¸€ä¸ªerrorCallbackï¼Œè¿™æ ·å¥½å¤„æ˜¯é™åˆ¶ç”¨æˆ·åœ¨éå‡½æ•°ç»„ä»¶çš„æ—¶å€™ä½¿ç”¨hookæŠ¥é”™
  const prevDispatcher = pushDispatcher();

  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
    // åˆå§‹åŒ–æ˜¯è¿›å…¥è¿™é‡Œï¼ŒworkInProgressRoot ï¼ŒworkInProgressRootRenderLanesæ­¤æ—¶éƒ½æ˜¯undefined
    // åˆ›å»º workInProgressï¼ŒworkInProgressRootï¼ŒworkInProgressRootRenderLanesï¼Œä¸‹é¢ä¼šå±•å¼€ 
    prepareFreshStack(root, lanes);
    // è®°å½•äº¤äº’çš„ï¼Œå­˜å‚¨åœ¨rootä¸­ï¼ŒmemoizedInteractionså­—æ®µ
    startWorkOnPendingInteractions(root, lanes);
  }

  do {
    try {
      // é‡ç‚¹æ˜¯è¿™ä¸ªæ–¹æ³•ï¼Œè¿›è¡Œé€’å½’ç”Ÿæˆfiberæ ‘
      workLoopSync();
      break;
    } catch (thrownValue) {
      handleError(root, thrownValue);
    }
  } while (true);

  // Set this to null to indicate there's no in-progress render.
  workInProgressRoot = null;
  workInProgressRootRenderLanes = NoLanes;
  return workInProgressRootExitStatus;
}

```

##### prepareFreshStack

> åœ¨ä¸Šæ–‡ï¼Œ`renderRootSync` ,ä¸­è°ƒç”¨äº† `prepareFreshStack` è¿™ä¸ªæ–¹æ³•ï¼Œæ­£å¼åˆå§‹åŒ– `workInProgress` æ ‘ï¼Œåˆ›å»º å’Œ current èŠ‚ç‚¹å¾ˆç›¸ä¼¼çš„fiberèŠ‚ç‚¹  ã€‚`packages/react-reconciler/src/ReactFiberWorkLoop.old.js`ã€‚
>
> é‚£ `workInProgress` ä¸­ä¸ºä»€ä¹ˆå¯ä»¥ä¸€ç›´é€’å½’ä¸‹å»çš„ï¼Ÿ

```tsx
function prepareFreshStack(root: FiberRoot, lanes: Lanes) {
  // root:fiberRootNode lanes:1
  root.finishedWork = null;
  root.finishedLanes = NoLanes;
  // è¿™é‡Œå¯ä»¥çœ‹å‡ºæ¥ workInProgressRoot å³æ˜¯fiberRootNode
  workInProgressRoot = root;
  // åˆ›å»º workInProgress,å®ƒçš„å†…å®¹æ˜¯å’Œroot.currentä¸€æ ·çš„ï¼Œå¹¶ä¸”å½“ current å­˜åœ¨çš„æ—¶å€™å¯ä»¥è¿›è¡Œå¤ç”¨å¤„ç†ã€‚
  workInProgress = createWorkInProgress(root.current, null);
  workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;
  workInProgressRootExitStatus = RootIncomplete;
  workInProgressRootFatalError = null;
  workInProgressRootSkippedLanes = NoLanes;
  workInProgressRootUpdatedLanes = NoLanes;
  workInProgressRootPingedLanes = NoLanes;

  if (enableSchedulerTracing) {
    spawnedWorkDuringRender = null;
  }
}

// é€šè¿‡ current åˆ›å»º workInProgressï¼Œå¹¶ä½¿ç”¨ alternate ç›¸äº’æŒ‡å‘ã€‚
export function createWorkInProgress(current: Fiber, pendingProps: any): Fiber {
  // è¿™ä¸ªworkInProgress æŒ‡å‘current.alternate;
  let workInProgress = current.alternate;
  // workInProgress:null
  if (workInProgress === null) {
    // ä½¿ç”¨åŒç¼“å­˜æŠ€æœ¯ï¼Œé€šè¿‡ä¸¤æ£µæ ‘å¯ä»¥æ–¹ä¾¿å¤ç”¨ä¸€äº›èŠ‚ç‚¹ï¼Œå¹¶ä¸”å¯ä»¥å»¶è¿Ÿåˆ›å»ºå“ªäº›ä¸ä¼šæ›´æ–°çš„å¯¹è±¡ï¼ŒåŒæ ·å¯ä»¥å›æ”¶ä¸€äº›é¢å¤–çš„å†…å­˜
    // åˆ›å»ºfiberï¼Œå’Œåˆ›å»ºfiberNodeæ˜¯åŒä¸€ä¸ªæ–¹æ³•
    workInProgress = createFiber( current.tag, pendingProps, current.key, current.mode,);
    workInProgress.elementType = current.elementType;
    workInProgress.type = current.type;
    workInProgress.stateNode = current.stateNode;

    if (__DEV__) {
      // DEV-only fields
      workInProgress._debugID = current._debugID;
      workInProgress._debugSource = current._debugSource;
      workInProgress._debugOwner = current._debugOwner;
      workInProgress._debugHookTypes = current._debugHookTypes;
    }
    // åŒç¼“å­˜ç»“æ„
    workInProgress.alternate = current;
    current.alternate = workInProgress;
  } 
  // å¤ç”¨ current å†…å®¹ã€‚
  else {
    workInProgress.pendingProps = pendingProps;
    // Needed because Blocks store data on type.
    workInProgress.type = current.type;

    // We already have an alternate.
    // Reset the effect tag.
    workInProgress.flags = NoFlags;

    // The effect list is no longer valid.
    workInProgress.nextEffect = null;
    workInProgress.firstEffect = null;
    workInProgress.lastEffect = null;

    if (enableProfilerTimer) {
      // We intentionally reset, rather than copy, actualDuration & actualStartTime.
      // This prevents time from endlessly accumulating in new commits.
      // This has the downside of resetting values for different priority renders,
      // But works for yielding (the common case) and should support resuming.
      workInProgress.actualDuration = 0;
      workInProgress.actualStartTime = -1;
    }
  }

  workInProgress.childLanes = current.childLanes;
  workInProgress.lanes = current.lanes;

  workInProgress.child = current.child;
  workInProgress.memoizedProps = current.memoizedProps;
  workInProgress.memoizedState = current.memoizedState;
  workInProgress.updateQueue = current.updateQueue;

  // Clone the dependencies object. This is mutated during the render phase, so
  // it cannot be shared with the current fiber.
  const currentDependencies = current.dependencies;
  workInProgress.dependencies =
    currentDependencies === null
      ? null
      : {
          lanes: currentDependencies.lanes,
          firstContext: currentDependencies.firstContext,
        };

  // These will be overridden during the parent's reconciliation
  workInProgress.sibling = current.sibling;
  workInProgress.index = current.index;
  workInProgress.ref = current.ref;

  if (enableProfilerTimer) {
    workInProgress.selfBaseDuration = current.selfBaseDuration;
    workInProgress.treeBaseDuration = current.treeBaseDuration;
  }

  if (__DEV__) {
    workInProgress._debugNeedsRemount = current._debugNeedsRemount;
    switch (workInProgress.tag) {
      case IndeterminateComponent:
      case FunctionComponent:
      case SimpleMemoComponent:
        workInProgress.type = resolveFunctionForHotReloading(current.type);
        break;
      case ClassComponent:
        workInProgress.type = resolveClassForHotReloading(current.type);
        break;
      case ForwardRef:
        workInProgress.type = resolveForwardRefForHotReloading(current.type);
        break;
      default:
        break;
    }
  }

  return workInProgress;
}
```

è‡³æ­¤å›¾åº”è¯¥é•¿è¿™æ ·çš„ã€‚

<img src="images/image-20220304032422194.png" alt="image-20220304032422194" style="zoom:50%;" />

##### workLoopSync

> åœ¨ä¸Šæ–‡ä¸­ï¼Œ`renderRootSync` é€šè¿‡ `do while` å¾ªç¯è°ƒç”¨ `workLoopSync` è¿›è¡Œé€’å½’åŒæ­¥æ¸²æŸ“çš„å·¥ä½œï¼Œ`packages/react-reconciler/src/ReactFiberWorkLoop.old.js`ã€‚

```tsx
function workLoopSync() {
  // å½“workInProgressæœ‰å†…å®¹çš„æ—¶å€™å°±ä¼šå¾ªç¯æ‰§è¡ŒperformUnitOfWorkï¼Œç›´åˆ°æ²¡æœ‰
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}

// workInProgress ä¹Ÿå°±æ˜¯unitOfWork ä¸€å¼€å§‹æ˜¯FiberNodeï¼Œç„¶åä¸æ–­å»é€’å½’è¿™æ£µæ ‘ï¼Œå½“ workInProgress ä¸ºnullæ—¶é€€å‡ºã€‚
function performUnitOfWork(unitOfWork: Fiber): void {
  // The current, flushed, state of this fiber is the alternate. Ideally
  // nothing should rely on this, but relying on it here means that we don't
  // need an additional field on the work in progress.
  // å®ƒè¯´è¿™é‡Œä¾èµ–è¿™ä¸ªalternateï¼Œå¯ä»¥ä¸ç”¨æ·»åŠ é¢å¤–çš„å­—æ®µ
  const current = unitOfWork.alternate;

  let next;
  // unitOfWork.mode :8 ProfileMode:8
  if (enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode) {
    // èµ‹å€¼ä¸¤ä¸ªæ—¶é—´ï¼ŒprofilerStartTime = now(), fiber.actualStartTime = now() 
    startProfilerTimer(unitOfWork);
    // è¿™ä¸ªnext æ°¸è¿œéƒ½æ˜¯è¿”å› å„¿å­èŠ‚ç‚¹ï¼Œæ·±åº¦ä¼˜å…ˆéå†ï¼Œä¸‹é¢ä¼šå±•å¼€
    next = beginWork(current, unitOfWork, subtreeRenderLanes);
    // fiber.actualDuration = now() - profilerStartTimeï¼Œfiber.selfBaseDuration = elapsedTimeï¼ŒprofilerStartTime = -1;
    // çŸ¥é“æ‰§è¡Œäº†å¤šé•¿æ—¶é—´ï¼Œä»¥åŠæ¢å¤ profilerStartTime
    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
  } else {
    next = beginWork(current, unitOfWork, subtreeRenderLanes);
  }

  // è®°å½•ä¸Šä¸€æ¬¡çš„å€¼
  unitOfWork.memoizedProps = unitOfWork.pendingProps;
  if (next === null) {
    // If this doesn't spawn new work, complete the current work.
    // å½“nextæ²¡æœ‰äº†ï¼Œä¹Ÿå°±æ˜¯è¯´æ·±åº¦æœç´¢è¿™æ£µæ ‘å·²ç»åˆ°å¤´äº†ï¼Œå¯ä»¥å¼€å§‹å®ŒæˆèŠ‚ç‚¹äº†ã€‚
    // ä¸¤ç§ï¼š1.å½“å‰èŠ‚ç‚¹æ²¡æœ‰å­èŠ‚ç‚¹äº†ï¼Œ2.å½“å‰èŠ‚ç‚¹çš„å­èŠ‚ç‚¹å…¨éƒ¨éƒ½completeUnitOfWorkå®Œæˆäº†
    // ä¸‹é¢ä¼šå±•å¼€
    completeUnitOfWork(unitOfWork);
  } else {
    // è¿™é‡ŒåˆæŠŠå…¨å±€å˜é‡ä¸­çš„workInProgressèµ‹å€¼ä¸ºnextï¼Œä¸ºå¤–å±‚çš„whileå¾ªç¯æä¾›æ¡ä»¶
    workInProgress = next;
  }
  /**
   * Keeps track of the current owner.
   *
   * The current owner is the component who should own any components that are
   * currently being constructed.
   */
  ReactCurrentOwner.current = null;
}

```

###### beginWork

> é€’å½’æ„å»ºfiberæ ‘ï¼Œ`/packages/react-reconciler/src/ReactFiberBeginWork.old.js`,beginæ˜¯æ€ä¹ˆå¤„ç†èŠ‚ç‚¹çš„ï¼Œè¿™äº›å‚æ•°å¯¹å®ƒæ¥è¯´å¥½åƒæ— æ³•ç»§ç»­é€’å½’ä¸‹å»ã€Œcurrent, unitOfWork, subtreeRenderLanesã€ã€‚`beginWork` æ˜¯ä¸æ–­çš„å¾€ä¸‹æ‰¾ï¼Œå’Œæ·±åº¦ä¼˜å…ˆæœç´¢çš„æ€æƒ³æ˜¯ä¸€æ ·çš„ã€‚

```tsx
// beginWork çš„å…¥å‚æ˜¯ä¸€å¯¹ç”¨ alternate è¿æ¥èµ·æ¥çš„ workInProgress å’Œ current èŠ‚ç‚¹ï¼›
// beginWork çš„æ ¸å¿ƒé€»è¾‘æ˜¯æ ¹æ® fiber èŠ‚ç‚¹ï¼ˆworkInProgressï¼‰çš„ tag å±æ€§çš„ä¸åŒï¼Œè°ƒç”¨ä¸åŒçš„èŠ‚ç‚¹åˆ›å»ºå‡½æ•°ã€‚
function beginWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
  
  // current: ä¸€å¼€å§‹æ˜¯fiberRootNode.current ä¸­fiberNode
  // workInProgress å½“å‰çš„fiberï¼Œç¬¬ä¸€æ¬¡æ˜¯current
  // renderLanes:1
  const updateLanes = workInProgress.lanes;


  // 1.æ›´æ–°é€»è¾‘çš„æ—¶å€™ï¼Œcurrentä¸ä¸ºnullï¼Œ2.ç¬¬ä¸€æ¬¡è¿›æ¥çš„currentä¸ä¸ºnullï¼Œå› ä¸ºå®ƒæ˜¯ç¬¬ä¸€ä¸ªfiberNodeèŠ‚ç‚¹
  if (current !== null) {
    // å¯¹æ¯”ä¸¤ä¸ªprops
    const oldProps = current.memoizedProps;
    const newProps = workInProgress.pendingProps;
    // è‹¥ props æ›´æ–°ã€ä¸Šä¸‹æ–‡æ”¹å˜æˆ– type æ”¹å˜äº†ï¼Œåˆ™è®¤ä¸ºéœ€è¦"æ¥å—æ›´æ–°"
    if ( oldProps !== newProps || hasLegacyContextChanged() ||
      // Force a re-render if the implementation changed due to hot reload:
      (__DEV__ ? workInProgress.type !== current.type : false)
    ) {
      // If props or context changed, mark the fiber as having performed work.
      // This may be unset if the props are determined to be equal later (memo).
      didReceiveUpdate = true; // æ›´æ–°æ ‡è®°
    } else if (!includesSomeLane(renderLanes, updateLanes)) {
      didReceiveUpdate = false;
      // This fiber does not have any pending work. Bailout without entering
      // the begin phase. There's still some bookkeeping we that needs to be done
      // in this optimized path, mostly pushing stuff onto the stack.
      switch (workInProgress.tag) { ... }
      // ä»¥åæœ‰äº†currentåï¼Œå¹¶ä¸”æ»¡è¶³æ¡ä»¶å°±ä¼šå¤ç”¨ current åˆ° workInProgress
      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    } else {
      if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
        // This is a special case that only exists for legacy mode.
        // See https://github.com/facebook/react/pull/19216.
        didReceiveUpdate = true;
      } else {
        // An update was scheduled on this fiber, but there are no new props
        // nor legacy context. Set this to false. If an update queue or context
        // consumer produces a changed value, it will set this to true. Otherwise,
        // the component will assume the children have not changed and bail out.
        // ç¬¬ä¸€æ¬¡è¿›æ¥ä¼šç»™æ›´æ–°æ‰“ä¸Šä¸€ä¸ªä¸ç”¨æ›´æ–°çš„æ ‡è®°
        didReceiveUpdate = false;
      }
    }
  } else {
    didReceiveUpdate = false;
  }

  // Before entering the begin phase, clear pending update priority.
  // TODO: This assumes that we're about to evaluate the component and process
  // the update queue. However, there's an exception: SimpleMemoComponent
  // sometimes bails out later in the begin phase. This indicates that we should
  // move this assignment out of the common path and into each branch.
  workInProgress.lanes = NoLanes;
  
  switch (workInProgress.tag) {
    // ç¬¬äºŒæ¬¡ï¼Œå½“ worikInprogress app ç»„ä»¶ ä¼šè¿›æ¥è¿™é‡Œ,é€šè¿‡ workInProgress.type è°ƒç”¨ Commponet æ–¹æ³• è·å–jsx
    case IndeterminateComponent: { // tagï¼š2,
      return mountIndeterminateComponent( current, workInProgress,  workInProgress.type, renderLanes,);
    }
    case FunctionComponent: { ... }
    case ClassComponent: { ... }
    // æ ¹èŠ‚ç‚¹ï¼Œç¬¬ä¸€æ¬¡ä¼šè¿›æ¥è¿™é‡Œ,è¿™é‡Œæ˜¯åˆ›å»ºapp
    case HostRoot:
      return updateHostRoot(current, workInProgress, renderLanes);
    // ç¬¬ä¸‰æ¬¡ï¼Œdom æ ‡ç­¾ï¼Œdivæ ‡ç­¾
    case HostComponent:
      return updateHostComponent(current, workInProgress, renderLanes);
    // æ–‡æœ¬èŠ‚ç‚¹ 
    case HostText:
      return updateHostText(current, workInProgress);
  }
}

```

###### completeUnitOfWork

> `completeUnitOfWork` æ˜¯ `beginWork`  æ‰¾åˆ°å¤´äº†ã€Œæ²¡æœ‰å­èŠ‚ç‚¹å¯ä»¥ç»§ç»­å¾€ä¸‹é¢æ‰¾ã€ï¼Œå¼€å§‹æ‰§è¡Œ completeUnitOfWorkï¼Œå½“æ‰¾åˆ°å…„å¼Ÿåï¼ŒbeginWork  åˆä¼šé‡æ–°è¢«è°ƒç”¨ã€‚å› ä¸ºworkInProgress ä¼šè¢«æ›´æ–°ã€‚`completeUnitOfWork:/react/packages/react-reconciler/src/ReactFiberWorkLoop.old.js`ã€`completeWork: /packages/react-reconciler/src/ReactFiberCompleteWork.old.js`

```tsx
function completeUnitOfWork(unitOfWork: Fiber): void {
  // å®Œæˆåç§»åŠ¨åˆ° siblingï¼Œæ²¡æœ‰ siblingï¼Œè¿”å›parentï¼Œè®©parentå»åˆ¤æ–­ä¸‹ä¸€æ­¥æ˜¯ siblingã€parentã€‚
  let completedWork = unitOfWork;
  do {
    const current = completedWork.alternate;
    const returnFiber = completedWork.return; // çˆ¶èŠ‚ç‚¹
   
    // current åˆå§‹åŒ–ï¼Œcurrentä¸ºnullï¼Œé™¤äº†å›å»åˆ°<app/>å“ªé‡Œæ‰æ˜¯æœ‰æ•°æ®çš„ã€Œå› ä¸ºå®ƒæ˜¯æå‰åˆ›å»ºå‡ºæ¥çš„ã€
    // completedWork:å½“å‰å·¥ä½œçš„fiber
    // subtreeRenderLanes:1
    startProfilerTimer(completedWork);
    // åˆ›å»ºdomå…ƒç´ æŒ‚è½½åˆ° stateNodeä¸­
    next = completeWork(current, completedWork, subtreeRenderLanes);
    // NOTE: next !== nullï¼ŒcompleteWorkæ‰¾åˆ°äº† siblingï¼Œè¿”å›åˆ° workLoopSyncï¼Œå¼€å¯ sibling çš„ beginWork å·¥ä½œ
    // next !== null è¿™ç§æƒ…å†µè¿˜æ˜¯æ¯”è¾ƒå°‘çš„ï¼Œçœ‹è§æœ‰SuspenseListComponentç›¸å…³æ‰ä¼šï¼Œä¸»è¦é€»è¾‘è¿˜æ˜¯åœ¨ä¸‹é¢é€šè¿‡ sibling æ‰¾
    // next === nullï¼Œéœ€è¦è¿”å›åˆ°æ‰¾å”å”ï¼Œåé¢ä¼šæœ‰é€»è¾‘åˆ†æ 
    if (next !== null) {
      // Completing this fiber spawned new work. Work on that next.
      workInProgress = next;
      return;
    }
    
  
    // è·å–å½“å‰èŠ‚ç‚¹çš„å…„å¼ŸèŠ‚ç‚¹
    const siblingFiber = completedWork.sibling;
    // å…„å¼ŸèŠ‚ç‚¹å­˜åœ¨
    if (siblingFiber !== null) {
      // If there is more work to do in this returnFiber, do that next.
      // å°† workInProgress èµ‹å€¼ä¸ºå½“å‰èŠ‚ç‚¹çš„å…„å¼ŸèŠ‚ç‚¹
      workInProgress = siblingFiber;
      // è¿”å›å‡ºå»ä½†æ˜¯returnæ²¡æœ‰å¤„ç†,è¿™é‡Œåªæ˜¯åšä¸€ä¸ªä¸­æ–­å‡½æ•°æ‰§è¡Œ
      // workLoopSync ç»§ç»­æ‰§è¡Œä¸Šä¸‹ä¸€ä¸ªsiblingFiber beginWorkï¼Œ
      return;
    }
    // Otherwise, return to the parent
    // å°†çˆ¶äº²è¿”å›å‡ºå»
    completedWork = returnFiber;
    // Update the next thing we're working on in case something throws.
    workInProgress = completedWork;
  } while (completedWork !== null);
}


function completeWork(current: Fiber | null, workInProgress: Fiber,renderLanes: Lanes,): Fiber | null {
  const newProps = workInProgress.pendingProps;
  switch (workInProgress.tag) {
    case FunctionComponent: // 3
      return null;
    case HostRoot: { // 3
      popHostContainer(workInProgress);
      popTopLevelLegacyContextObject(workInProgress);
      resetMutableSourceWorkInProgressVersions();
      const fiberRoot = (workInProgress.stateNode: FiberRoot);
      if (fiberRoot.pendingContext) {
        fiberRoot.context = fiberRoot.pendingContext;
        fiberRoot.pendingContext = null;
      }
      if (current === null || current.child === null) {
        // If we hydrated, pop so that we can delete any remaining children
        // that weren't hydrated.
        const wasHydrated = popHydrationState(workInProgress);
        if (wasHydrated) {
          // If we hydrated, then we'll need to schedule an update for
          // the commit side-effects on the root.
          markUpdate(workInProgress);
        } else if (!fiberRoot.hydrate) {
          // Schedule an effect to clear this container at the start of the next commit.
          // This handles the case of React rendering into a container with previous children.
          // It's also safe to do for updates too, because current.child would only be null
          // if the previous render was null (so the the container would already be empty).
          workInProgress.flags |= Snapshot;
        }
      }
      updateHostContainer(workInProgress);
      return null;
    }
    // åˆ›å»ºæ™®é€šæ ‡ç­¾
    case HostComponent: { // 5
      // fiber Stack å‡ºæ ˆ
      popHostContext(workInProgress);
      // rootContainerInstance : ä¸€ç›´æ˜¯ <div id='id'></div> çœŸå®çš„domå…ƒç´ 
      const rootContainerInstance = getRootHostContainer();
      
      const type = workInProgress.type;
      // stateNode != null å°±ä¼šèµ°æ›´æ–°é€»è¾‘äº†
      if (current !== null && workInProgress.stateNode != null) {
        updateHostComponent(current, workInProgress,type,newProps, rootContainerInstance );
        if (current.ref !== workInProgress.ref) {
          markRef(workInProgress);
        }
      } else {
        // è·å–ä¸Šä¸‹æ–‡
        const currentHostContext = getHostContext();
        // TODO: Move createInstance to beginWork and keep it on a context
        // "stack" as the parent. Then append children as we go in beginWork
        // or completeWork depending on whether we want to add them top->down or
        // bottom->up. Top->down is faster in IE11.
        // æµè§ˆå™¨æ¸²æŸ“ï¼Œè¿™é‡Œè¿”å› false
        const wasHydrated = popHydrationState(workInProgress); 

        // é‡Œé¢çš„é€»è¾‘éƒ½æ˜¯åœ¨åˆ›å»ºdomå…ƒç´  <p>0</p>
        // type:è¿”å›æ ‡ç­¾ç±»å‹ï¼Œdiv,p
        // newProps:å¦‚æœä½¿ç”¨useState(0)=>{children: 0}
        // currentHostContext:å½“å‰hostçš„ä¸Šä¸‹æ–‡
        // åˆ›å»ºä¸€ä¸ªå«æœ‰å†…å®¹çš„çœŸå®domèŠ‚ç‚¹
        const instance = createInstance(type,newProps,rootContainerInstance,  currentHostContext, workInProgress);
         
        // appendAllChildren æŠŠä¸Šä¸€æ­¥åˆ›å»ºå¥½çš„ DOM èŠ‚ç‚¹æŒ‚è½½åˆ° DOM æ ‘ä¸Šå»
        // å°† DOM èŠ‚ç‚¹æ’å…¥åˆ° DOM æ ‘é‡Œå»ï¼Œå®é™…ä¸Šæ˜¯å°†å­ Fiber èŠ‚ç‚¹æ‰€å¯¹åº”çš„ DOM èŠ‚ç‚¹æŒ‚è½½åˆ°å…¶çˆ¶ Fiber èŠ‚ç‚¹æ‰€å¯¹åº”çš„ DOM èŠ‚ç‚¹é‡Œå»ã€‚
        // é‚£å°†ä¼šå‡ºç°ä¸€ä¸ªé—®é¢˜ï¼Œå¦‚æœæ‰§è¡Œ appendAllChildren æ—¶ï¼Œçˆ¶çº§çš„ DOM èŠ‚ç‚¹è¿˜ä¸å­˜åœ¨æ€ä¹ˆåŠï¼Ÿ
        // æ¯”å¦‚ <div><h1>hello</h1></div>  h1 èŠ‚ç‚¹ä½œä¸ºç¬¬ä¸€ä¸ªè¿›å…¥ completeWork çš„èŠ‚ç‚¹ï¼Œå®ƒçš„çˆ¶èŠ‚ç‚¹ div å¯¹åº”çš„ DOM å°±å°šä¸å­˜åœ¨ã€‚
        // å…¶å®ä¸å­˜åœ¨ä¹Ÿæ²¡å…³ç³»ï¼Œåæ­£ h1 DOM èŠ‚ç‚¹è¢«åˆ›å»ºåï¼Œä¼šä½œä¸º h1 Fiber èŠ‚ç‚¹çš„ stateNode å±æ€§å­˜åœ¨ï¼Œä¸¢ä¸æ‰çš„ã€‚
        // å½“çˆ¶èŠ‚ç‚¹ div è¿›å…¥ appendAllChildren é€»è¾‘åï¼Œä¼šé€ä¸ªå‘ä¸‹æŸ¥æ‰¾å¹¶æ·»åŠ è‡ªå·±çš„åä»£èŠ‚ç‚¹ã€‚
        // æ‰€ä»¥æœ€åæ ¹èŠ‚ç‚¹divï¼Œå³æ˜¯appç»„ä»¶ä¸‹é¢çš„divæ˜¯æ‹¥æœ‰å…¨éƒ¨å­˜åœ¨å†…å­˜ä¸­domï¼Œ
        appendAllChildren(instance, workInProgress, false, false);
        // stateNode ç”¨äºå­˜å‚¨å½“å‰ Fiber èŠ‚ç‚¹å¯¹åº”çš„ DOM èŠ‚ç‚¹
        workInProgress.stateNode = instance;
      
      }
      return null;
    }
 }
```

è‡³æ­¤fiberç»“æ„åº”è¯¥é•¿è¿™æ ·ï¼ŒåŠ ä¸€æ®µè¯æè¿°è¿™ä¸ªç»“æ„ã€‚

<img src="images/image-20220309032925411.png" alt="image-20220309032925411" style="zoom:50%;" />

### Commit é˜¶æ®µ

> å›åˆ° `performSyncWorkOnRoot` æ–¹æ³•é‡Œï¼Œ`/packages/react-reconciler/src/ReactFiberWorkLoop.old.js`,åˆ°æœ€åé¢ä¼šå»è°ƒç”¨ 	`commitRoot`,å¼€å¯ `commit` é˜¶æ®µã€‚

```tsx
function commitRoot(root) {
  const renderPriorityLevel = getCurrentPriorityLevel();
  // è¿™é‡Œå°±æ˜¯å°±æ˜¯è°ƒç”¨ commitRootImpl å‡½æ•°
  runWithPriority( ImmediateSchedulerPriority, commitRootImpl.bind(null, root, renderPriorityLevel),
);
  return null;
}


function commitRootImpl(root, renderPriorityLevel) {
  do {
    // flushPassiveEffects ä¼šåœ¨æœ€åè°ƒç”¨ flushSyncUpdateQueueï¼Œå®ƒæœ‰æ—¶ä¼šæœ‰å‰¯ä½œç”¨ï¼Œ æ‰€ä»¥éœ€è¦å¾ªç¯åˆ·æ–°å‰¯ä½œç”¨ï¼Œç›´åˆ°æ‰€æœ‰çš„å‰¯ä½œç”¨éƒ½æ‰§è¡Œäº†
    flushPassiveEffects();
  } while (rootWithPendingPassiveEffects !== null);

  const finishedWork = root.finishedWork; // fiberRootNode ä¸‹é¢çš„ current
  const lanes = root.finishedLanes; // 1

  // æ¸…ç©º finishedWorkã€finishedLanesã€å›è°ƒ æ•°æ®
  root.finishedWork = null;
  root.finishedLanes = NoLanes;
  root.callbackNode = null;


  // Get the list of effects.
  let firstEffect;
  // å¸¸é‡PerformedWork:1
  // finishedWork.flags:256 æˆ–è€…å…¶ä»– æ¯”1å¤§çš„æ•°å­—
  // å‰¯ä½œç”¨ç›¸å…³ï¼Œæ”¶é›†å‰¯ä½œç”¨ï¼Œ
  if (finishedWork.flags > PerformedWork) {
    if (finishedWork.lastEffect !== null) {
      finishedWork.lastEffect.nextEffect = finishedWork;
      firstEffect = finishedWork.firstEffect;
    } else {
      firstEffect = finishedWork;
    }
  } else {
    // There is no effect on the root.
    firstEffect = finishedWork.firstEffect;
  }

  // æœ‰å‰¯ä½œç”¨ï¼Œæ‰§è¡Œcommitä¸‰ä¸ªå­é˜¶æ®µ
  if (firstEffect !== null) {
    // ç¬¬ä¸€ä¸ªé˜¶æ®µä¸º before mutationï¼Œé€’å½’ è¯»å–ç»„ä»¶å˜æ›´å‰çš„çŠ¶æ€ã€‚
    // ç±»ç»„ä»¶ï¼Œè°ƒç”¨getSnapshotBeforeUpdateï¼Œè®©æˆ‘ä»¬å¯ä»¥åœ¨DOMå˜æ›´å‰è·å–ç»„ä»¶å®ä¾‹çš„ä¿¡æ¯ï¼›
    // å‡½æ•°ç»„ä»¶ï¼Œè°ƒåº¦useEffectï¼Œå…³äºuseEffectæ‰§è¡Œé€»è¾‘æœ‰ç‚¹å¤æ‚ï¼ŒåæœŸå¾—å¯¹hooksè¡¥è¯¾
    focusedInstanceHandle = prepareForCommit(root.containerInfo); // null
    shouldFireAfterActiveInstanceBlur = false;

    nextEffect = firstEffect;
    // å°†å‰¯ä½œç”¨é“¾è¡¨æ‰§è¡Œä¸€éã€‚
    do {
        try {
          // ä¸‹é¢å±•å¼€
          commitBeforeMutationEffects();
        } catch (error) {
          invariant(nextEffect !== null, 'Should be working on an effect.');
          captureCommitPhaseError(nextEffect, error);
          nextEffect = nextEffect.nextEffect;
      }
    } while (nextEffect !== null);

    // ç¬¬äºŒä¸ªé˜¶æ®µ mutationé˜¶æ®µï¼Œä¸‹é¢å±•å¼€ã€‚
    nextEffect = firstEffect;
    do {
        try {
          commitMutationEffects(root, renderPriorityLevel);
        } catch (error) {
          invariant(nextEffect !== null, 'Should be working on an effect.');
          captureCommitPhaseError(nextEffect, error);
          nextEffect = nextEffect.nextEffect;
      }
    } while (nextEffect !== null);

    if (shouldFireAfterActiveInstanceBlur) {
      afterActiveInstanceBlur();
    }

    // å°†  work-in-progress æ ‘ åˆ‡æ¢æˆ current treeï¼Œ
    // componentWillUnmountä¼šåœ¨mutationé˜¶æ®µæ‰§è¡Œã€‚æ­¤æ—¶current Fiberæ ‘è¿˜æŒ‡å‘å‰ä¸€æ¬¡æ›´æ–°çš„Fiberæ ‘ï¼Œåœ¨ç”Ÿå‘½å‘¨æœŸé’©å­å†…è·å–çš„DOMè¿˜æ˜¯æ›´æ–°å‰çš„ã€‚
    // componentDidMountå’ŒcomponentDidUpdateä¼šåœ¨layouté˜¶æ®µæ‰§è¡Œã€‚
    // æ­¤æ—¶current Fiberæ ‘å·²ç»æŒ‡å‘æ›´æ–°åçš„Fiberæ ‘ï¼Œåœ¨ç”Ÿå‘½å‘¨æœŸé’©å­å†…è·å–çš„DOMå°±æ˜¯æ›´æ–°åçš„ã€‚
    root.current = finishedWork;

    // ç¬¬ä¸‰ä¸ªé˜¶æ®µ layout é˜¶æ®µï¼Œä¸‹é¢å±•å¼€
    nextEffect = firstEffect;
    do {
        try {
          commitLayoutEffects(root, lanes);
        } catch (error) {
          invariant(nextEffect !== null, 'Should be working on an effect.');
          captureCommitPhaseError(nextEffect, error);
          nextEffect = nextEffect.nextEffect;
        }
    } while (nextEffect !== null);

    nextEffect = null;

    // Tell Scheduler to yield at the end of the frame, so the browser has an
    // opportunity to paint.
    // è®© Scheduler é€€å‡ºï¼Œæµè§ˆå™¨å°±å¯ä»¥é‡æ–°ç»˜åˆ¶ï¼Œè®¾ç½®ä¸€ä¸ªç©ºçš„å‡½æ•°
    requestPaint(); 
  }
}
```



#### before mutation

> é€’å½’ è¯»å–ç»„ä»¶å˜æ›´å‰çš„çŠ¶æ€ã€‚ç±»ç»„ä»¶ï¼Œè°ƒç”¨getSnapshotBeforeUpdateï¼Œè®©æˆ‘ä»¬å¯ä»¥åœ¨DOMå˜æ›´å‰è·å–ç»„ä»¶å®ä¾‹çš„ä¿¡æ¯ï¼›å‡½æ•°ç»„ä»¶ï¼Œè°ƒç”¨useEffectï¼Œå…³äºuseEffectæ‰§è¡Œé€»è¾‘æœ‰ç‚¹å¤æ‚ï¼ŒåæœŸå¾—å¯¹hooksè¡¥è¯¾

```tsx
function commitBeforeMutationEffects() {
  // å¾ªç¯å‰¯ä½œç”¨é“¾è¡¨
  while (nextEffect !== null) {
    const current = nextEffect.alternate;
    // shouldFireAfterActiveInstanceBlurï¼šfalseï¼Œ focusedInstanceHandleï¼šnull
    if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {
      if ((nextEffect.flags & Deletion) !== NoFlags) {
        if (doesFiberContain(nextEffect, focusedInstanceHandle)) {
          shouldFireAfterActiveInstanceBlur = true;
          // å¤„ç†blur
          beforeActiveInstanceBlur();
        }
      } else {
        // TODO: Move this out of the hot path using a dedicated effect tag.
        if (
          nextEffect.tag === SuspenseComponent &&
          isSuspenseBoundaryBeingHidden(current, nextEffect) &&
          doesFiberContain(nextEffect, focusedInstanceHandle)
        ) {
          shouldFireAfterActiveInstanceBlur = true;
          beforeActiveInstanceBlur();
        }
      }
    }

    const flags = nextEffect.flags;
    if ((flags & Snapshot) !== NoFlags) {
      setCurrentDebugFiberInDEV(nextEffect);
      // ç±»ç»„ä»¶çš„getSnapshotBeforeUpdate æ–¹æ³•
      commitBeforeMutationEffectOnFiber(current, nextEffect);

      resetCurrentDebugFiberInDEV();
    }
    // è°ƒåº¦useEffect
    if ((flags & Passive) !== NoFlags) {
      // If there are passive effects, schedule a callback to flush at
      // the earliest opportunity.
      if (!rootDoesHavePassiveEffects) {
        rootDoesHavePassiveEffects = true;
        scheduleCallback(NormalSchedulerPriority, () => {
          flushPassiveEffects();
          return null;
        });
      }
    }
    nextEffect = nextEffect.nextEffect;
  }
}
```

#### mutation

> è´Ÿè´£ DOM èŠ‚ç‚¹çš„æ¸²æŸ“ã€‚åœ¨æ¸²æŸ“è¿‡ç¨‹ä¸­ï¼Œä¼šéå† effectListï¼Œæ ¹æ® flags çš„ä¸åŒï¼Œæ‰§è¡Œä¸åŒçš„ DOM æ“ä½œï¼Œ é’ˆå¯¹ç±»ç»„ä»¶ï¼Œè°ƒç”¨componentWillUnmountï¼›é’ˆå¯¹å‡½æ•°ç»„ä»¶ï¼Œæ‰§è¡ŒuseEffectã€useLayoutEffectçš„é”€æ¯å‡½æ•°ã€‚

```tsx
function commitMutationEffects( root: FiberRoot, renderPriorityLevel: ReactPriorityLevel) {
  // å¾ªç¯å‰¯ä½œç”¨é“¾è¡¨
  while (nextEffect !== null) {
    setCurrentDebugFiberInDEV(nextEffect);

    const flags = nextEffect.flags;
    // é‡ç½®å†…å®¹
    if (flags & ContentReset) {
      commitResetTextContent(nextEffect);
    }

    // æ¸…ç©ºREF
    if (flags & Ref) {
      const current = nextEffect.alternate;
      if (current !== null) {
        commitDetachRef(current);
      }
      if (enableScopeAPI) {
        // TODO: This is a temporary solution that allowed us to transition away
        // from React Flare on www.
        if (nextEffect.tag === ScopeComponent) {
          commitAttachRef(nextEffect);
        }
      }
    }

    const primaryFlags = flags & (Placement | Update | Deletion | Hydrating);
    switch (primaryFlags) {
      case Placement: {
        // æ’å…¥èŠ‚ç‚¹
        // getHostSiblingæ˜¯ä¸€ä¸ªè´¹æ—¶çš„æ“ä½œï¼ŒåŸå› æ˜¯å› ä¸ºï¼ŒworkInProgressæ ‘å’Œdomæ ‘å±‚çº§æœ‰å¯èƒ½ä¸ä¸€è‡´çš„ï¼Œæ‰€ä»¥å°±ä¼šæœ‰è·¨çº§çš„æ“ä½œï¼Œå°±ä¼šæœ‰æŒ‡æ•°çº§åˆ«çš„è´¹æ—¶æ“ä½œã€‚
        commitPlacement(nextEffect);
        // Clear the "placement" from effect tag so that we know that this is
        // inserted, before any life-cycles like componentDidMount gets called.
        // TODO: findDOMNode doesn't rely on this any more but isMounted does
        // and isMounted is deprecated anyway so we should be able to kill this.
        nextEffect.flags &= ~Placement;
        break;
      }
      case PlacementAndUpdate: {
        // Placement
        commitPlacement(nextEffect);
        // Clear the "placement" from effect tag so that we know that this is
        // inserted, before any life-cycles like componentDidMount gets called.
        nextEffect.flags &= ~Placement;

        // Update
        const current = nextEffect.alternate;
        commitWork(current, nextEffect);
        break;
      }
      case Update: {
        const current = nextEffect.alternate;
        commitWork(current, nextEffect);
        break;
      }
      case Deletion: {
        commitDeletion(root, nextEffect, renderPriorityLevel);
        break;
      }
    }

    resetCurrentDebugFiberInDEV();
    nextEffect = nextEffect.nextEffect;
  }
}
```

#### layout 

> å¤„ç† DOM æ¸²æŸ“å®Œæ¯•ä¹‹åçš„æ”¶å°¾é€»è¾‘ã€‚è¯»å–ç»„ä»¶çš„çŠ¶æ€ï¼Œé’ˆå¯¹ç±»ç»„ä»¶ï¼Œè°ƒç”¨ç”Ÿå‘½å‘¨æœŸcomponentDidMountå’ŒcomponentDidUpdateï¼Œè°ƒç”¨setStateçš„å›è°ƒã€‚é’ˆå¯¹å‡½æ•°ç»„ä»¶ï¼Œè°ƒç”¨useLayoutEffecté’©å­å‡½æ•°çš„å›è°ƒç­‰ã€‚

```tsx
function commitLayoutEffects(root: FiberRoot, committedLanes: Lanes) {
  // å¾ªç¯å‰¯ä½œç”¨é“¾è¡¨
  while (nextEffect !== null) {
    const flags = nextEffect.flags;
    if (flags & (Update | Callback)) {
      const current = nextEffect.alternate;
      // è°ƒç”¨ç”Ÿå‘½å‘¨æœŸé’©å­å’Œhook
      commitLayoutEffectOnFiber(root, current, nextEffect, committedLanes);
    }

    if (enableScopeAPI) {
      // TODO: This is a temporary solution that allowed us to transition away
      // from React Flare on www.
      if (flags & Ref && nextEffect.tag !== ScopeComponent) {
        // ç»™refå±æ€§èµ‹å€¼ä¸Šæ–°çš„domå…ƒç´ 
        commitAttachRef(nextEffect);
      }
    } else {
      if (flags & Ref) {
        commitAttachRef(nextEffect);
      }
    }
    nextEffect = nextEffect.nextEffect;
  }
}

// 
function commitLifeCycles(
  finishedRoot: FiberRoot,
  current: Fiber | null,
  finishedWork: Fiber,
  committedLanes: Lanes,
): void {
  switch (finishedWork.tag) {
    case FunctionComponent:
    case ForwardRef:
    case SimpleMemoComponent:
    case Block: {
      if (enableProfilerTimer && enableProfilerCommitHooks &&finishedWork.mode & ProfileMode ) {
        try {
          startLayoutEffectTimer();
          // æ‰§è¡ŒuseLayoutEffectçš„å›è°ƒå‡½æ•°
          commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork);
        } finally {
          recordLayoutEffectDuration(finishedWork);
        }
      } else {
        commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork);
      }
      // è°ƒåº¦useEffectçš„é”€æ¯å‡½æ•°ä¸å›è°ƒå‡½æ•°
      schedulePassiveEffects(finishedWork);
      return;
    }
    case ClassComponent: {
      const instance = finishedWork.stateNode;
      if (finishedWork.flags & Update) {
        // Mount é˜¶æ®µï¼Œ è§¦å‘componentDidMount
        if (current === null) {
          instance.componentDidMount();
        }
        // Updata é˜¶æ®µï¼Œè§¦å‘componentDidUpdate
         else {
          const prevProps =
            finishedWork.elementType === finishedWork.type
              ? current.memoizedProps
              : resolveDefaultProps(finishedWork.type, current.memoizedProps);
          const prevState = current.memoizedState;
          // We could update instance props and state here,
          // but instead we rely on them being set during last render.
          // TODO: revisit this when we implement resuming.
         	instance.componentDidUpdate(prevProps,prevState,instance.__reactInternalSnapshotBeforeUpdate);
         }
      }
  }
}
```



## æ€»ç»“

è‡³æ­¤ï¼ŒReactDOM.renderçš„åˆå§‹åŒ–å·²ç»å®Œæ¯•äº†ï¼Œå®ƒæ˜¯åŒæ­¥æ¸²æŸ“çš„ã€‚



## æ›´æ–°é˜¶æ®µ

> æ›´æ–°é˜¶æ®µä¼šåˆ†ä¸ºç¬¬ä¸€æ¬¡æ›´æ–°å’Œç¬¬1+næ¬¡æ›´æ–°ï¼Œç¬¬ä¸€æ¬¡æ›´æ–°è¿˜æ˜¯ä¼šåˆ›å»ºworkInProgressï¼Œå› ä¸ºå½“å‰çš„current çš„altenateéƒ½ä¸ºnullï¼Œç¬¬1+næ¬¡åï¼Œcurrent çš„altenateéƒ½æœ‰fiberèŠ‚ç‚¹ï¼Œæ‰€ä»¥éƒ½å¯ä»¥è¿›è¡Œå¤ç”¨ã€‚





## åŒæ­¥çš„ ReactDOM.renderï¼Œå¼‚æ­¥çš„ ReactDOM.createRoot

åœ¨ React 17 ç‰ˆæœ¬ä¸­ï¼ŒReact éƒ½æœ‰ä»¥ä¸‹ 3 ç§å¯åŠ¨æ–¹å¼ï¼š

**legacy æ¨¡å¼**ï¼š
`ReactDOM.render(<App />, rootNode)`ã€‚è¿™æ˜¯å½“å‰ React App ä½¿ç”¨çš„æ–¹å¼ã€‚
**blocking æ¨¡å¼**ï¼š
`ReactDOM.createBlockingRoot(rootNode).render(<App />)`ã€‚ç›®å‰æ­£åœ¨å®éªŒä¸­ï¼Œä½œä¸ºè¿ç§»åˆ° concurrent æ¨¡å¼çš„ç¬¬ä¸€ä¸ªæ­¥éª¤ã€‚

**concurrent æ¨¡å¼**ï¼š
`ReactDOM.createRoot(rootNode).render(<App />)`ã€‚ç›®å‰åœ¨å®éªŒä¸­ï¼Œæœªæ¥ç¨³å®šä¹‹åï¼Œæ‰“ç®—ä½œä¸º React çš„é»˜è®¤å¼€å‘æ¨¡å¼ï¼Œè¿™ä¸ªæ¨¡å¼å¼€å¯äº†æ‰€æœ‰çš„æ–°åŠŸèƒ½ã€‚