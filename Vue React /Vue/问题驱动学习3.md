### 1.双向绑定和 Vuex 是否冲突?

```js

当在严格模式中使用 Vuex 时，在属于 Vuex 的 state 上使用 v-model 会比较棘手：

<input v-model="obj.message">
假设这里的 obj 是在计算属性中返回的一个属于 Vuex store 的对象，在用户输入时，v-model 会试图直接修改 obj.message。在严格模式中，由于这个修改不是在 mutation 函数中执行的, 这里会抛出一个错误。

用“Vuex 的思维”去解决这个问题的方法是：给 <input> 中绑定 value，然后侦听 input 或者 change 事件，在事件回调中调用一个方法:

<input :value="message" @input="updateMessage">

computed: {
  ...mapState({
    message: state => state.obj.message
  })
},
methods: {
  updateMessage (e) {
    this.$store.commit('updateMessage', e.target.value)
  }
}
mutations: {
  updateMessage (state, message) {
    state.obj.message = message
  }
}


或者
<input v-model="message" />
computed: {
    message: {
        set (value) {
            this.$store.dispatch('updateMessage', value);
        },
        get () {
            return this.$store.state.obj.message
        }
    }
}
mutations: {
    UPDATE_MESSAGE (state, v) {
        state.obj.message = v;
    }
}
actions: {
    update_message ({ commit }, v) {
        commit('UPDATE_MESSAGE', v);
    }
}
```

### 2. Vue.set 的原理?

```js
 ../observer/index 中找出set函数
function set (target: Array<any> | Object, key: any, val: any): any {
  if (process.env.NODE_ENV !== 'production' &&
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(`Cannot set reactive property on undefined, null, or primitive value: ${(target: any)}`)
  }
  // 数组的情况下，通过调用Vue中的 arrayMethods 下面的 7个方法之一
  // splice push pop unshift shift reverse sort，通过调用这些方法可以监听数据，
  // 并把数组里面的每一项进行监听
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key)
    target.splice(key, 1, val)
    return val
  }
  // 通过给对象赋值
  if (key in target && !(key in Object.prototype)) {
    target[key] = val
    return val
  }
  const ob = (target: any).__ob__
  if (target._isVue || (ob && ob.vmCount)) {
    process.env.NODE_ENV !== 'production' && warn(
      'Avoid adding reactive properties to a Vue instance or its root $data ' +
      'at runtime - declare it upfront in the data option.'
    )
    return val
  }
  if (!ob) {
    target[key] = val
    return val
  }
  // 监听当前对象
  defineReactive(ob.value, key, val)
  // 收集依赖
  ob.dep.notify()
  return val
}
```

### 3.为什么 Vue3.0proxy 解决了什么问题，为什么性能更好？

```js
Vue2.0
对象：添加属性的时候 obj.a = 1 会无法被Vue2劫持，必须使用Vue2提供的$set方法来进行更新
因为defineProperty只能对当前对象中的属性进行监听一个个去监听，新增加进来的，需要重新使用defineProperty，但是Vue是不知道什么时候去使用defineProperty。

Vue3.0中，使用proxy来进行数据代理就完全没有这个顾虑了
const p = new Proxy({
    a: 1,
    b: 2,
}, {
    get: function(obj, value) {
        console.log('get', obj, value);
        return Reflect.get(obj, value);
    },
    set: function(obj, prop, value) {
        console.log('set', obj, prop, value);
        return Reflect.set(obj, prop, value);
    },
})

proxy对于数据的代理，是能够响应新增的属性，当新增一个属性的时候，可以响应到get中，对当前对象进行代理


数组:Vue针对数组是多做了一层处理，代理了数组的7个方法，这是因为使用Object.defineProperty在数组上面天然存在劣势，所以数组的修改也是无法侦听的，需要通过方法去修改值。
const a = new Proxy([1,2], {
    get: function(obj, prop) {
        console.log('get', obj, prop);
        return Reflect.get(obj, prop);
    },
    set: function(obj, prop, value) {
        console.log('set', obj, prop, value);
        return Reflect.set(obj, prop, value);
    },
});
a.push(1);

get [1,2] push
get [1,2] length
set [1,2] 2 3
set [1,2, 3] length 3

由于proxy会触发两次，Vue3只会在prop为length值才进行更新

Vue2 如果没有设置Object.freeze默认递归data里面的数据做响应式处理，所以不建议在data中的数据定义嵌套太多层，Vue3的proxy是懒递归，不会一上来就递归，性能就相对好点
```

#### Vue compile 过程详细说一下，指令、插值表达式等 vue 语法如何生效的?

```

```

#### Vue 中内置组件 transition、transition-group 的源码实现原理?

#### 知道 Vue 生命周期内部怎么实现的么 ?

```
将渲染的组件，父组件子组件的生命周期钩子，推进一个数组，然后通过callHook函数执行相应的钩子函数
```

#### 2.Vue 的执行流程?

```
先对选项对象初始化，通过Object.defineProperty建立一套响应式系统，然后将模板先解析成AST对象 再解析成render函数，然后使用render函数生成vnode，在渲染前，对vnode进行diff操作，最后进行必要的渲染


AST对象：
{
   attrs: [{name: "id", value: ""app"", dynamic: undefined, start: 5, end: 13}],
   attrsList: [{name: "id", value: "app", start: 5, end: 13}],
   attrsMap: {id: "app"},
   children: [{
        attrsList: [],
        attrsMap: {},
        children: [],
        end: 33,
        parent: {type: 1, tag: "div", ...},
        plain: true,
        pre: undefined,
        rawAttrsMap:{},
        start: 19
        tag: "p",
        type: 1
   }],
   end: 263,
   parent: undefined,
   plain: false,
   rawAttrsMap:{id: {name: "id", value: "app", start: 5, end: 13}},
   start: 0
   tag: "div",
   type: 1
}

render 函数
with(this){
    return _c('div', {attrs:{"id":"app"}}, [_c('p', [_v(_s(msg))])])
}

虚拟dom {
    tag: "div",
    children: [{tag: "p", ...}],
    data: {attrs: {id: "app"}}
    elm: DOM节点（div#app）,
    parent: undefined,
    context: Vue实例,
    ...
}
```

#### **8.**什么是作用域插槽**?**

![image-20210514095018396](../../static/images/image-20210514095018396.png)

```js
理解:
1.插槽:
<app><div slot="a">xxxx</div><div slot="b">xxxx</div></app>
slot name="a"
slot name="b"

创建组件虚拟节点时，会将组件的儿子的虚拟节点保存起来。当初始化组件时,通过插槽属性将儿 子进行分类 {a:[vnode],b[vnode]} 渲染组件时会拿对应的slot属性的节点进行替换操作。(插槽的作用域为父组件)

2.作用域插槽: 作用域插槽在解析的时候，不会作为组件的孩子节点。会解析成函数，当子组件渲染时，会调用此
函数进行渲染。(插槽的作用域为子组件)
原理:
 插槽
const VueTemplateCompiler = require('vue-template-compiler'); let ele = VueTemplateCompiler.compile(`
<my-component>
<div slot="header">node</div> <div>react</div>
<div slot="footer">vue</div>
</my-component> `)
/**
with(this) {
return _c('my-component', [_c('div', {
            attrs: {
                "slot": "header"
},
slot: "header"
}, [_v("node")] // _文本节点
    ), _v(" "), _c('div', [_v("react")]), _v(" "), _c('div', {
        attrs: {
            "slot": "footer"
        },
        slot: "footer"
    }, [_v("vue")])])
} */
const VueTemplateCompiler = require('vue-template-compiler');

let ele = VueTemplateCompiler.compile(` <div>
        <slot name="header"></slot>
        <slot name="footer"></slot>
        <slot></slot>
</div> `);
/**
with(this) {
return _c('div', [_v("node"), _v(" "), _t(_v("vue")])]), _v(" "), _t("default")], 2)
}
**/
// _t定义在 core/instance/render-helpers/index.js

作用域插槽
let ele = VueTemplateCompiler.compile(` <app>
<div slot-scope="msg" slot="footer">{{msg.a}}</div> </app>
`);
/** with(this) {
return _c('app', {
scopedSlots: _u([{ // 作用域插槽的内容会被渲染成一个函数
            key: "footer",
            fn: function (msg) {
return _c('div', {}, [_v(_s(msg.a))]) }
}]) })
} }
*/
const VueTemplateCompiler = require('vue-template-compiler');
VueTemplateCompiler.compile(` <div>
        <slot name="footer" a="1" b="2"></slot>
    </div>
`);
/** with(this) {
    return _c('div', [_t("footer", null, {
        "a": "1",
        "b": "2"
    })], 2)
} **/
```

#### **8.** **v-model 中的实现原理及如何自定义 v-model**

```js
v-model 可以看成是 value+input方法 的语法糖

<el-checkbox :value="" @input=""></el-checkbox>
<el-checkbox v-model="check"></el-checkbox>

可以自己重新定义 v-model 的含义
Vue.component('el-checkbox',{
template:`<input type="checkbox" :checked="check"
@change="$emit('change',$event.target.checked)">`,
  model:{
		prop:'check', // 更改默认的value的名字
		event:'change' // 更改默认的方法名 },
		props: {
    check: Boolean
  }, })

原理:
会将组件的 v-model 默认转化成value+input

const VueTemplateCompiler = require('vue-template-compiler');
const ele = VueTemplateCompiler.compile('<el-checkbox v-model="check"></el- checkbox>');
// with(this) {
//		return _c('el-checkbox', { model: {
//			value: (check),
//			callback: function ($$v) {
//			check = $$v },
//			expression: "check"
//
//
//         }
//     })
// }

core/vdom/create-component.js line:155

function transformModel (options, data: any) {
	const prop = (options.model && options.model.prop) || 'value'
  const event = (options.model && options.model.event) || 'input' ;
  (data.attrs || (data.attrs = {}))[prop] = data.model.value
  const on = data.on || (data.on = {})
	const existing = on[event]
	const callback = data.model.callback
	if (isDef(existing)) {
		if ( Array.isArray(existing) ? existing.indexOf(callback) === -1: existing !== callback ){
			on[event] = [callback].concat(existing) }
  } else {
    on[event] = callback
} }


原生的 v-model ，会根据标签的不同生成不同的事件和属性

const VueTemplateCompiler = require('vue-template-compiler');
const ele = VueTemplateCompiler.compile('<input v-model="value"/>');
/**
with(this) {
    return _c('input', {
        directives: [{
name: "model", rawName: "v-model", value: (value), expression: "value"
        }],
        domProps: {
            "value": (value)
        },
        on: {
            "input": function ($event) {
if ($event.target.composing) return;
value = $event.target.value
}}})}
*/

编译时:不同的标签解析出的内容不一样 platforms/web/compiler/directives/model.js

if (el.component) {
genComponentModel(el, value, modifiers)
// component v-model doesn't need extra runtime return false
  } else if (tag === 'select') {
    genSelect(el, value, modifiers)
  } else if (tag === 'input' && type === 'checkbox') {
    genCheckboxModel(el, value, modifiers)
  } else if (tag === 'input' && type === 'radio') {
    genRadioModel(el, value, modifiers)
  } else if (tag === 'input' || tag === 'textarea') {
    genDefaultModel(el, value, modifiers)
} else if (!config.isReservedTag(tag)) { genComponentModel(el, value, modifiers)
// component v-model doesn't need extra runtime return false
}

运行时:会对元素处理一些关于输入法的问题
platforms/web/runtime/directives/model.js

inserted (el, binding, vnode, oldVnode) { if (vnode.tag === 'select') {
// #6903
if (oldVnode.elm && !oldVnode.elm._vOptions) { mergeVNodeHook(vnode, 'postpatch', () => {
directive.componentUpdated(el, binding, vnode) })
} else {
setSelected(el, binding, vnode.context)
}
el._vOptions = [].map.call(el.options, getValue)
} else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
el._vModifiers = binding.modifiers if (!binding.modifiers.lazy) {
el.addEventListener('compositionstart', onCompositionStart) el.addEventListener('compositionend', onCompositionEnd)
// Safari < 10.2 & UIWebView doesn't fire compositionend when // switching focus before confirming composition choice
// this also fixes the issue where some browsers e.g. iOS Chrome // fires "change" instead of "input" on autocomplete. el.addEventListener('change', onCompositionEnd)
/* istanbul ignore if */
if (isIE9) { el.vmodel = true
}
   } }
}
```

#### **9.** Vue 中事件绑定的原理

![image-20210514092754323](../../static/images/image-20210514092754323.png)

```
编译阶段
Vue在挂载实例前，有相当多的工作是进行模板的编译，将template模板进行编译，解析成AST树，再转换成render函数，而在编译阶段，就是对事件的指令做收集处理。
在template模板中，定义事件的部分是属于XML的Attribute，所以收集指令时需要匹配Attributes以确定哪个Attribute是属于事件。


Vue 的事件绑定分为两种一种是原生的事件绑定，还有一种是组件的事件绑定,

理解:
1.原生 dom 事件的绑定,采用的是 addEventListener 实现
2.组件绑定事件采用的是 $on 方法，$emit 触发

原理: 事件的编译:

let compiler = require('vue-template-compiler');

// 通过addEventListener 将事件绑定到dom元素上
let r1 = compiler.compile('<div @click="fn()"></div>');
// 可以通过addEventListener 将事件绑定到dom元素上，不过需要加上native描述符
// 还有通过Vue内部 $on 和 $emit 对事件进行管理
let r2 = compiler.compile('<my-component @click.native="fn" @click="fn1"></my- component>');
console.log(r1); // `with(this){return _c('div',{on:{"click":function($event){return fn()}}})}`
console.log(r2);
//  `with(this){return _c('my-component',{on:{"click":fn1},nativeOn:{"click":function($event){return fn($event)}}})}`


1.原生 的绑定
Vue 在创建真实 dom 时会调用 createElm ,默认会调用 invokeCreateHooks
会遍历当前平台下相对的属性处理代码,其中就有 updateDOMListeners 方法,内部会传入 add 方法
vue 中绑定事件是直接绑定给真实 dom 元素的

function updateDOMListeners (oldVnode: VNodeWithData, vnode: VNodeWithData) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
		return
	}
	const on = vnode.data.on || {}
	const oldOn = oldVnode.data.on || {}
	target = vnode.elm
	normalizeEvents(on)
	updateListeners(on, oldOn, add, remove, createOnceHandler, vnode.context)
	target = undefined
}
function add (
  name: string,
  handler: Function,
  capture: boolean,
  passive: boolean
){
target.addEventListener( // 给当前的dom添加事件
    name,
    handler,
    supportsPassive
      ? { capture, passive }
: capture )
}


2.组件中绑定事件
组件绑定事件是通过 vue 中自定义的 $on 方法来实现的


export function updateComponentListeners (
  vm: Component,
  listeners: Object,
  oldListeners: ?Object
){
target = vm
updateListeners(listeners, oldListeners || {}, add, remove, createOnceHandler,vm)
 target = undefined
}
function add (event, fn) { target.$on(event, fn)
}
```
