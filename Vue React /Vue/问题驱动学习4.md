# Vue问答题 基于element-ui

## **怎么重置数据**

```
1.逐个赋值
2.使用 Object.assign(this.data, this.$options.data())
3.重置 data 中某个对象或属性，比如this.params：this.params = this.$options.data().params


重置from表单的数据 this.$refs[formName].resetFields();
```



## **在vue事件中传入$event，使用e.target和e.currentTarget有什么区别**

```
e.currentTarget：指向事件所绑定的元素，所以一直不变。
e.target：始终指向事件发生时的元素，会变。

一般情况下，他们是相同的，但是当存在父子关系时。在父级绑定事件。
1.当我们点击 父级时，e.currentTarget === e.target === 父级
2.当我们点击 子元素时，e.currentTarget ===  父级，e.target === 所点击的元素
```

## **vue怎么实现强制刷新组件**

```
1.如果要在组件内部中进行强制刷新
调用this.$forceUpdate()强制重新渲染组件
2.如果是刷新某个子组件
利用v-if指令的特性
3.当组件的key 值变更时，会自动的重新渲染
4.如果上面的办法都没有效果，可以考虑使用watch
```



## **计算属性，函数名和data数据源中的数据可以同名吗**

```
可以同名，但data会覆盖methods。并且本就不该同名，同名说明你命名不规范。
然后解释为什么会覆盖，因为Props、methods、data、computed、watch都是在initState函数中被初始化的。初始化顺序就是我上面给出的顺序，本质上这些都是要挂载到this上面的，你如果重名的话，后面出现的属性自然而然会覆盖之前挂载的属性了。如果你的eslint配置比较严格的话，同名是编译不通过的。
```

## **怎么给vue定义全局的方法**

```
1、通过prototype，这个非常方便。Vue.prototype[method]=method;
2、通过插件Vue.use(plugin)；
3、通过mixin，Vue.mixin(mixins);
```

## **vue的:class和:style有几种表示方式**

```
:class 绑定变量 绑定对象 绑定一个数组 绑定三元表达式
:style 绑定变量 绑定对象 绑定函数返回值 绑定三元表达式

以class举例
绑定对象 <div :class="{classA:a , classB: b,...}"/></div>
绑定变量 <div :class="test"></div>
绑定一个数组 <div :class="[test1,test2]"></div>
绑定三元表达式 <div :class="true?'signSpanChange':'signSpan'" ></div>
new Vue({
    el:'#app',
    data:{
        a:true,//根据true/false判断是否执行class
        b:true,
        test:{
                color:red;
                background:yellow;
        },
        test1Class:test1,
        test2Class:test2,
        

    }
})
```

## **组件中写name选项有什么作用**

```
1.项目使用keep-alive时，可搭配组件name进行缓存过滤
2.DOM做递归组件时需要调用自身name
3.vue-devtools调试工具里显示的组见名称是由vue中组件name决定的
```

## **对动态组件&&异步组件的理解**

```js
让多个组件使用同一个挂载点，并动态切换，这就是动态组件。

https://cn.vuejs.org/v2/guide/components-dynamic-async.html
https://segmentfault.com/a/1190000012138052
异步组件的功能就是，当我们的项目很大的时候，加载特别慢，可以考虑使用异步组件「不是特别重要的组件可以使用这种方式」来加载（需要的时候才去加载）。
可以减少内存开销，加快渲染速度。

使用
来自vue官网
const AsyncComponent = () => ({
  // 需要加载的组件 (应该是一个 `Promise` 对象)
  component: import('./MyComponent.vue'),
  // 异步组件加载时使用的组件
  loading: LoadingComponent,
  // 加载失败时使用的组件
  error: ErrorComponent,
  // 展示加载时组件的延时时间。默认值是 200 (毫秒)
  delay: 200,
  // 如果提供了超时时间且组件加载也超时了，
  // 则使用加载失败时使用的组件。默认值是：`Infinity`
  timeout: 3000
})
```



## **表单修饰符和事件修饰符以及用途**

```
事件修饰符.stop .prevent .capture .self .once .passive
表单修饰符.number .lazy .trim
```

## **用vue怎么实现一个换肤的功能**

```
方法一。
1.通过用户选择相应的颜色，
2.将颜色加进去到最外层的样式（style）里面，使用 !important。将后面用到的选择器都加上。

大概如下。
 style.innerHTML = ` .top-bar-container, .top-bar-container .byui-main, .side-bar-container, .logo-container-vertical, .logo-container-horizontal, .el-menu, .el-menu-item, .el-submenu.is-active.is-opened, .el-submenu__title, .el-menu-item.is-active, .el-menu-item .is-active { background-color:${menuBackground}!important; } body .el-menu--horizontal .top-bar-item-container  .el-menu-item:hover, body .el-menu--horizontal .top-bar-item-container .el-menu-item.is-active, body .app-wrapper .side-bar-container .el-submenu .el-menu-item.is-active, body .app-wrapper .side-bar-container  .el-menu-item:hover,body .side-bar-container .el-menu .el-menu-item.is-active{ background-color:${menuBackgroundActive}!important; } .tags-view-item.router-link-exact-active.router-link-active.active{ background-color: ${tagViewsBackgroundActive}!important; border: 1px solid ${tagViewsBackgroundActive}!important; } .el-button.el-button--primary{background-color: ${buttonBackground}!important;border-color: ${buttonBackground}!important;} .el-pagination.is-background .el-pager li:not(.disabled).active{background-color: ${paginationBackgroundActive}!important;border-color: ${paginationBackgroundActive}!important;}body .app-wrapper .side-bar-container .nest-menu .el-menu-item {background-color: ${menuChildrenBackground} !important;}`;

方法二。
预先配置好主题，通过切换主题即可。也可以模仿上面的操作，也可以使用 gulp-css-wrap
```

