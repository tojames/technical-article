### 解构赋值

**解构赋值**语法是一种 Javascript 表达式。通过**解构赋值,** 可以将属性/值从对象/数组中取出,赋值给其他变量。

解构赋值用得好,也是一种修养,我发现MDN已经写的非常的详细了,但是他也有一些没有说到的,我这个主要是加强一下自己的熟悉度吧和进行一点补充~~以下是MDN的解构赋值的URL

<https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment>

`数组解构:` “模式匹配”,只要等号两边的模式相同，左边的变量就会被赋予匹配的右边的值，如果匹配不成功变量的值就等于undefined

```js
我们以前比较low的写法
let foo = [1,2,3];
let a = foo[0];
let b = foo[1];
let c = foo[2];
//上面这种麻烦,low,不优雅.

let foo = ["one", "two", "three"]; 
let [one, two, three] = foo; 
//首先声明一下这些变量,接着进行模式匹配 两边都是数组 按照顺序对应起来,如果匹配不成功变量的值就等于undefined
console.log(one); // "one"
console.log(two); // "two"
console.log(three); // "three"
```

`对象解构`:

```js
let ab = {a:1,b:2};
let a = ab.a;  //1
let b = ab.b;  //2
//上面这种麻烦,low,不优雅.

let cd = {c:3,d:4};
let {c,d} = cd;
//首先声明一下这些变量,接着进行模式匹配,两边都是对象,变量必须与属性同名才能取到正确的值,这一点区别于数组
console.log(c);
console.log(d);
```

其实还有很多解构赋值的方式,总之能帮我简化代码的我们就采用,不能的话,那么就还是老老实实的写,避免可读性变差.

### 迭代和递归的区别

迭代可以转换为递归，但递归不一定可以转换为迭代。

采用递归算法需要的前提条件是，当且仅当一个存在预期的收敛时，才可采用递归算法，否则，就不能使用递归算法。

|      | 定义                               | 优点                                                         | 缺点                                                         |
| ---- | ---------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 递归 | 程序调用自身的编程技巧称为递归     | 1）大问题化为小问题,可以极大的减少代码量；2）用有限的语句来定义对象的无限集合.；3）代码更简洁清晰，可读性更好 | 1）递归调用函数,浪费空间；2）递归太深容易造成堆栈的溢出      |
| 迭代 | 利用变量的原值推算出变量的一个新值 | 1）迭代效率高，运行时间只因循环次数增加而增加；2）没什么额外开销，空间上也没有什么增加， | 1） 不容易理解；2） 代码不如递归简洁；3） 编写复杂问题时困难。 |

二者之间的关系  : 1） 递归中一定有迭代,但是迭代中不一定有递归,大部分可以相互转换。2） 能用迭代的不用递归,递归调用函数,浪费空间,并且递归太深容易造成堆栈的溢出.

迭代例子:

```js
//迭代实现斐波那契数列
function fab_iteration(num){  
	if (num == 1 || num == 2) {
        return 1;
    }
    else {
        let f1 = 1;
        let f2 = 1;
        let f3 = 0;
        for (let i = 0; i < num - 2; i++) {
            f3 = f1 + f2; //利用变量的原值推算出变量的一个新值  
            f1 = f2;
            f2 = f3;
        }
        return f3;
    }  
}
console.log(fab_iteration(3)); //2
//我们的for while forEach Map 等等都是用迭代写的.原因就是相比于递归当数据比较复杂的时候,不会浪费太多的栈空间.
```

递归例子:

```js
//递归实现斐波那契数列  
function fab_recursion(num) {
    if (num == 1 || num == 2) {
        return 1;
    }
    else {
        return fab_recursion(num - 1) + fab_recursion(num - 2);    //递归求值  
    }
}
console.log(fab_recursion(3)); //2
```

### 赋值和浅拷贝深拷贝的区别

谈论到这个话题就是涉及到数据类型,简单的数据类型就是除了复杂数据类型对象,数组,函数都是属于简单的数据类型,那么他们的区别就是简单的数据类型就放在栈空间,而复杂数据类型是放在堆空间,在栈空间会存放一个引用.

<font color="red">那么讨论的就要分为简单的数据类型和复杂的数据类型</font>

#### 赋值

​	简单的数据类型

```js
// 这里简单的数据类型我用字符串来举例子
let a = "Atoe";
let b = a;
console.log(a===b); // true	
b = "12";
console.log(a===b); // false 
// 解释其实很简单,首先 "Atoe"在栈里面开了一个空间,然后赋值给了a,a又赋值给了b,他们a,b这两个变量都是指向 同一个栈空间.
// 接着下面 "12"在栈里面创建了一个存放"12"的空间,然后赋值给了b. 好了结束
```

​       复杂数据类型

```js
// 这里的复杂数据类型我用对象
let aObj = {name:"atoe"};
let bObj = aObj;
console.log(aObj===bObj);  //true 

bObj.age = 22;
console.log(aObj===bObj); // true
console.log(aObj,bObj)    // {name: "atoe", age: 22},{name: "atoe", age: 22}

// 解释 {name:"atoe"}是一个复杂的数据类型,然后再对空间创建了一个空间来存放这个对象,又在栈空间创建了一个地址,这个地址指向这个对象,接着把这个地址赋值给aObj.aObj又赋值给bObj.所以他们的指向都是同一个对象,那么当然是全等.
//第二个,当我们在bObj里面添加属性age的时候,我们改变了bObj,但是bObj改变了是堆空间的对象,那么造成的原因就是aObj也跟着改变. 所以他们都是全等. 赋值解释清楚了
```

#### 浅拷贝

首先明白拷贝无论深浅都是针对复杂的数据类型来说的,简单的数据类型是没有的

那么什么叫浅拷贝呢?

浅拷贝就是被赋值要好一点,比深拷贝差一点. 那么怎么理解这家白话呢,就是"浅", 他只拷贝了对象的第一层,往后面的层都是赋值.(我没有解析的太清晰,代码见)

```js
let arr = [11,{name:"Atoe"},"123"];
let newArr = arr.slice(0,3); //[11,{name:"Atoe"},"123"]; 把0到3之间的内容切出来(不包含3),返回.
console.log(arr===newArr); // false

// 来,数组是复杂数据在堆创建空间,然后栈里面有一个引用赋值给arr, 下面,slice这个方法是对数组的一个切片,不会改变原来数据,返回一个新的数组,那么这里我切的是整个数组,然后让他们===,结果返回false,其实他们的数据类型,值都是一摸一样的,但是就是false,首先===(全等符所有的都比较,不符合就是flase).那么现在我们知道了arr和newArr不是一样的东西.是不是属于拷贝.但是我们不知道是深还是浅拷贝.
// 验证深浅拷贝
newArr[1].name = "果汁冰";
console.log(arr,newArr);
//  [11,{name:"果汁冰"},"123"],[11,{name:"果汁冰"},"123"]
//好了,这是我要说的点了,为什么改变了newArr这个数据同时也会改变arr,不是说他们完全没有关系吗?
//我一一说来:这就是所谓的浅拷贝,浅字就是值拷贝第一层(表层)的东西,如果第一层是有复杂数据类型拷贝的只是引用,
//那么就是说arr和newArr里面的{}对象就是一直是拷贝的是引用,你到时候改变他的时候还是回去堆空间找到真正的值改变他,所以改变newArr中的复杂对象的值也会影响到arr.
console.log(arr[1]===newArr[1]); // true 这个是不是验证我说的话? 复杂数据类型是不是相当于简单的赋值而已..
//继续验证 里面的简单数据类型是赋值,重新赋值不会改变另外一个对象的简单数据类型
newArr[0] =22
console.log(arr,newArr);
//  [11,{name:"果汁冰"},"123"],[22,{name:"果汁冰"},"123"]
// 是不是不会影响另外一个,以上是我想表达的浅拷贝的意思.

//还有一点就是数据对象有很多方法都是浅拷贝哦.可以去玩一下.splice 什么的
```

#### 深拷贝

深拷贝的意思就是复制出一个和真的一模一样的东西出来,不是高仿鞋,是真的.只不过他们存放的空间地址不是一样的.

​	实现深拷贝

​	最low的

```js
let arr = [11,{name:"Atoe"},"123"];
let newArr =  JSON.parse(JSON.stringify(arr));
console.log(arr,newArr); //[11,{name:"Atoe"},"123"] [11,{name:"Atoe"},"123"];\
console.log(arr===newArr);// false 
console.log(arr[1]===newArr[1]); // false
//那还需要解释吗?两个完全不一样的东西了,这是比较简单的深拷贝的方法,
//但是缺点贼多,不能拷贝 方法,undefined,...忘了.有空回来补上,但是实际用还是够用的
//原理就是序列化,先变为字符串,简单数据类型在栈空间,然后转为对象,在堆中创建了一个新的对象,所以呢,就不会和之前的有半毛钱的关系了.
```

