# splitChunks

当项目代码变大、变多依赖复杂，如果简单打包。

- 会出现重复打包，最后导致 `dist` 文件偏大，**文件大小需要优化**
- 重复打包后，文件重复引入，**http请求数需要优化**
- 文件打包后过大，过小，**过大：文件大小需要优化，过小：http请求数需要优化**

**解决问题：提取公共代码，防止代码被重复打包，拆分过大的 javascript 文件，合并零散的 javascript 文件**

从工程化角度思考，应该让打包工具去做，比如 Vite、Webpack、Glup、Rollup。

以 webpack 为例，从 `webpack4.0` 开始 `SplitChunksPlugin` 替代了 `CommonsChunkPlugin`，集成在 `webpack ` 中。通过配置webpack，让 SplitChunks 帮开发者解决这样的问题。



https://webpack.js.org/plugins/split-chunks-plugin/



## 使用和配置

集成在 `webpack ` 中，直接在 optimization.splitChunks 中配置即可，以下参数为默认值，官方：fit web performance best practices，但是每个项目肯定有所不同，以下将会解析每个配置带来的影响。

```js
module.exports = {
  //...
  optimization: {
    splitChunks: {
      chunks: 'async',
      minSize: 20000,
      minRemainingSize: 0,
      minChunks: 1,
      maxAsyncRequests: 30,
      maxInitialRequests: 30,
      enforceSizeThreshold: 50000,
      cacheGroups: {
        defaultVendors: {
          test: /[\\/]node_modules[\\/]/,
          priority: -10,
          reuseExistingChunk: true,
        },
        default: {
          minChunks: 2,
          priority: -20,
          reuseExistingChunk: true,
        },
      },
    },
  },
};
```



## 场景

**1. 为什么要进行代码分割？**
代码分割最基本的任务是分离出第三方依赖库，因为第三方库的内容可能很久都不会变动，所以用来标记变化的摘要哈希`contentHash`也很久不变，这也就意味着我们可以利用本地缓存来避免没有必要的重复打包，并利用浏览器缓存避免冗余的客户端加载。另外当项目发布新版本时，如果第三方依赖的`contentHash`没有变化，就可以使用客户端原来的缓存文件（通用的做法一般是给静态资源请求设置一个很大的`max-age`），提升访问速度。另外一些场景中，代码分割也可以提供对脚本在整个加载周期内的加载时机的控制能力。
**2. 代码分割的使用场景**
举个很常见的例子，比如你在做一个数据可视化类型的网站，引用到了百度的`Echarts`作为第三方库来渲染图表，如果你将自己的代码和`Echarts`打包在一起生成一个`main.bundle.js`文件，这样的结果就是在一个网速欠佳的环境下打开你的网站时，用户可能需要面对很长时间的白屏，你很快就会想到将`Echarts`从主文件中剥离出来，让体积较小的主文件先在界面上渲染出一些动画或是提示信息，然后再去加载`Echarts`，而分离出的`Echarts`也可以从速度更快的`CDN`节点获取，如果加载某个体积庞大的库，你也可以选择使用懒加载的方案，将脚本的下载时机延迟到用户真正使用对应的功能之前。这就是一种人工的代码分割。
从上面的例子整个的生命周期来看，我们将原本一次就可以加载完的脚本拆分为了两次，这无疑会加重服务端的性能开销，毕竟建立TCP连接是一种开销很大的操作，但这样做却可以换来**对渲染节奏的控制和用户体验的提升**，**异步模块**和**懒加载模块**从宏观上来讲实际上都属于**代码分割**的范畴。`code splitting`最极端的状况其实就是拆分成打包前的原貌，也就是**源码直接上线**。



- node_modules中的模块或其他被重复引用的模块
  就是说如果引用的模块来自`node_modules`,那么只要它被引用，那么满足其他条件时就可以进行自动分割。否则该模块需要被重复引用才继续判断其他条件。（对应的就是下文配置选项中的`minChunks`为1或2的场景）
- 分离前模块最小体积下限（默认30k，可修改）
  30k是官方给出的默认数值，它是可以修改的，上一节中已经讲过，每一次分包对应的都是服务端的性能开销的增加，所以必须要考虑分包的性价比。
- 对于异步模块，生成的公共模块文件不能超出5个（可修改）
  触发了懒加载模块的下载时，并发请求不能超过5个，对于稍微了解过服务端技术的开发者来说，**【高并发】**和**【压力测试】**这样的关键词应该不会陌生。
- 对于入口模块，抽离出的公共模块文件不能超出3个（可修改）
  也就是说一个入口文件的最大并行请求默认不得超过3个，原因同上。

