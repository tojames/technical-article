# 跨域

不支持跨域

```
cookie
LocalStorage
DOM元素也要同源策略iframe
ajax也不支持跨域
```

实现跨域的方式（9种）

```
jsonp 
postMessage
window.name
location.hash
document.domain
cors 后端设置允许请求头 'Access-Control-Allow-Origin'
websocket 
nginx
webpack（http-proxy） 代理 http serve 反响代理


```



# JSONP

> 只能发送get请求，不支持其他方式 
>
> 不安全 xss攻击，比如jsonp返回再次创建script标签的脚本

```js
利用浏览器script脚本的特性，也可以利用其他的标签，style也可以
通过拉取数据然后执行回调函数获取数据，即可。
function jsonp({ url, params, cb }) {
  return new Promise((resolve, reject) => {
    let srcipt = document.createElement('script')
    window[cb] = function(data) {
      resolve(data)
      document.body.removeChild(srcipt)
    }
    params = { ...params, cb }
    let arrs = []
    for (let key in params) {
      arrs.push(`${key}=${params[key]}`)
    }
    srcipt.src = `${url}?${arrs.join('&')}`
    document.body.appendChild(srcipt)
  })
}

jsonp({
  url: 'https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su',
  params: { wd: 'b' },
  cb: 'show'
}).then(data => {
  console.log(data, 'data')
})
```



# postMessage 、window.name、location.hash、document.domain

> 可以通过html页面的嵌套可以实现跨域处理

```
postMessage 
a页面
<iframe src="xx" id="iframe" onload="load()"></iframe>
function load(){
	let frame = doucument.getElementByid('#iframe')
	frame.contentWindow.postMessage('发送的内容',url)
	window.onmessage = function(e){
		console.log(e.data) // 接收到的参数
	}
}

b页面
window.onmessage = function(e){
	console.log(e.data) // 接收到的参数
	e.source.postMessage('发送的内容')
}


window.name 通过给name赋值。但是流程比较麻烦。


location.hash 通过把值放在hash上面，然后监听hanshchange事件

前提是数据互通是两个文件处在一级域名和二级域名的关系
document.domain 通过设置 document.domain = "一级域名"
```



# websocket

> 由于api具有全双工模式，不会受浏览器限制

```
高级api 不兼容老版本 需要使用socket.io做兼容

let socket = new WebSocket('ws:xxx')
socket.open = function(){
	socket.send("发送内容")
}
```



# nginx

> 服务器反向代理

```
nginx我们一般只会配置里面一些参数就可以了
nginx.conf
1.反向代理
反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器。地址，隐藏了真实服务器 IP 地址。
server:{ 
	listen 80;
	server_name 被访问ip地址
	location /{
		root html
		proxy pass 转发到想访问的ip地址
		index index.html index.html
	}
}
2.负载均衡
增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的 情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负 载均衡。
upstream myserve{
	server 192.168.17.129:8080 
	server 192.168.17.129:8081
}

server:{ 
	listen 80;
	server_name 被访问ip地址
	location /{
		root html
		proxy pass http://myserve
		index index.html index.htm
	}
}

3.动静分离
为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。
location /www/ {
	root /data/;
	index index.html index.htm
} 
location /image/{
	root /data/;
	autoindex on;
}
```

<img src="../../static/images/image-20210701173544572.png" alt="image-20210701173544572" style="zoom:50%;" />

<img src="../../static/images/image-20210701170615070.png" alt="image-20210701170615070" style="zoom:50%;" />

<img src="../../static/images/image-20210701170804904.png" alt="image-20210701170804904" style="zoom:50%;" />



# webpack（http-proxy）

> 前端项目服务器反向代理，通过http-serve

```js
// index.html(http://127.0.0.1:5500)
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
   <script>
     $.ajax({
       url: 'http://localhost:3000',
       type: 'post',
       data: { name: 'xiamen', password: '123456' },
       contentType: 'application/json;charset=utf-8',
       success: function(result) {
         console.log(result) // {"title":"fontend","password":"123456"}
       },
       error: function(msg) {
         console.log(msg)
       }
     })
    </script>


// server1.js 代理服务器(http://localhost:3000)
const http = require('http')
// 第一步：接受客户端请求
const server = http.createServer((request, response) => {
  // 代理服务器，直接和浏览器直接交互，需要设置CORS 的首部字段
  response.writeHead(200, {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': '*',
    'Access-Control-Allow-Headers': 'Content-Type'
  })
  // 第二步：将请求转发给服务器
  const proxyRequest = http
    .request(
      {
        host: '127.0.0.1',
        port: 4000,
        url: '/',
        method: request.method,
        headers: request.headers
      },
      serverResponse => {
        // 第三步：收到服务器的响应
        var body = ''
        serverResponse.on('data', chunk => {
          body += chunk
        })
        serverResponse.on('end', () => {
          console.log('The data is ' + body)
          // 第四步：将响应结果转发给浏览器
          response.end(body)
        })
      }
    )
    .end()
})
server.listen(3000, () => {
  console.log('The proxyServer is running at http://localhost:3000')
})


// server2.js(http://localhost:4000)
const http = require('http')
const data = { title: 'fontend', password: '123456' }
const server = http.createServer((request, response) => {
  if (request.url === '/') {
    response.end(JSON.stringify(data))
  }
})
server.listen(4000, () => {
  console.log('The server is running at http://localhost:4000')
})

```

