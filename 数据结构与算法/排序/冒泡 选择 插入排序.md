# 简单排序

> 冒泡排序、选择排序、插入排序，它们有一个共同的点就是 O(N^2)。
>
> 它们的效率依次为 冒泡排序 < 选择排序 < 插入排序



### 关于算法稳定

```
1、如果只是简单的进行数字的排序，那么稳定性将毫无意义。

2、如果排序的内容仅仅是一个复杂对象的某一个数字属性，那么稳定性依旧将毫无意义（所谓的交换操作的开销已经算在算法的开销内了，如果嫌弃这种开销，不如换算法好了？）

3、如果要排序的内容是一个复杂对象的多个数字属性，但是其原本的初始顺序毫无意义，那么稳定性依旧将毫无意义。

4、除非要排序的内容是一个复杂对象的多个数字属性，且其原本的初始顺序存在意义，那么我们需要在二次排序的基础上保持原有排序的意义，才需要使用到稳定性的算法，例如要排序的内容是一组原本按照价格高低排序的对象，如今需要按照销量高低排序，使用稳定性算法，可以使得想同销量的对象依旧保持着价格高低的排序展现，只有销量不同的才会重新排序。（当然，如果需求不需要保持初始的排序意义，那么使用稳定性算法依旧将毫无意义）。
```



## 冒泡排序

> 冒泡排序的思路是两个循环，第一轮找到最大值或者最小值，第二轮找到剩余的最大值或者最小值，如此循环下去即可



```js
function bubbleSort(arr) {
  // 第一个或者是最后一个是不需要比较的，所以 arr.length-1
  // debugger
  for (let i = 0; i < arr.length - 1; i++) {
    // i是已经排序后索引，或者说已经排序的项，所以需要把他重复的忽略 arr.length - i
    for (let j = 0; j < arr.length - i; j++) {
      if (arr[j] > arr[j + 1]) {
        let temp = arr[j]
        arr[j] = arr[j + 1]
        arr[j + 1] = temp
      }
    }
  }
  return arr
}

对于N个数据项，比较次数为：(N - 1) + (N - 2) + (N - 3) + ... + 1 = N * (N - 1) / 2；如果两次比较交换一次，那么交换次数为：N * (N - 1) / 4；
使用大O表示法表示比较次数和交换次数分别为：O（ N * (N - 1) / 2）和O（ N * (N - 1) / 4），根据大O表示法：O（N^2）;


时间复杂度（平均）：O（N^2）
时间复杂度（最坏）：O（N^2) 全部都需要交换
时间复杂度（最好）：O（N）全部都不需要交换
空间复杂度： O（1）
稳定性：稳定
```

![冒泡](../../static/images/冒泡.gif)



## 选择排序

> 其实思路和冒泡的差不多，只是将交换的次数降低到 O(N^2)
>
> 性能稍微提升一点点。



```js
function insertSort(arr) {
  // 第一个或者是最后一个是不需要比较的，所以 arr.length-1
  for (let i = 0; i < arr.length - 1; i++) {
    let min = i
    for (let j = min + 1; j < arr.length; j++) {
      if (arr[min] > arr[j]) {
        // 把最小值索引放进去
        min = j
      }
    }
    console.log(arr[min])
    let temp = arr[i]
    arr[i] = arr[min]
    arr[min] = temp
  }
  return arr
}

选择排序的比较次数为：N * (N - 1) / 2，用大O表示法表示为：O（N^2）;
选择排序的交换次数为：(N - 1) / 2，用大O表示法表示为：O（N）;

时间复杂度（平均）：O（N^2）
时间复杂度（最坏）：O（N^2) 全部都需要交换
时间复杂度（最好）：O（N）全部都不需要交换
空间复杂度： O（1）
稳定性：不稳定
```

![选择排序](../../static/images/选择排序.gif)



## 插入排序

> 插入排序是简单排序中效率**最高**的一种排序。
>
> 思路：
>
> - 插入排序思想的核心是**局部有序**。如图所示，X左边的人称为**局部有序**
>
> - 首先指定一数据X（从第一个数据开始），并将数据X的左边变成局部有序状态
>
> - 随后将X右移一位，再次达到局部有序之后，继续右移一位，重复前面的操作直至X移至最后一个元素。

```js
function insertSort(arr) {
  for (let i = 1; i < arr.length; i++) {
    let temp = arr[i]
    let j = i
    while (arr[j - 1] > temp && j > 0) {
      arr[j] = arr[j - 1]
      j--
    }
     arr[j - 1] = temp
  }
  return arr
}

比较次数：第一趟时，需要的最大次数为1；第二次最大为2；以此类推，最后一趟最大为N-1；所以，插入排序的总比较次数为N * (N - 1) / 2；但是，实际上每趟发现插入点之前，平均只有全体数据项的一半需要进行比较，所以比较次数为：N * (N - 1) / 4；

交换次数：指定第一个数据为X时交换0次，指定第二个数据为X最多需要交换1次，以此类推，指定第N个数据为X时最多需要交换N - 1次，所以一共需要交换N * (N - 1) / 2次，平均次数为N * (N - 1) / 2；

虽然用大O表示法表示插入排序的效率也是O（N^2），但是插入排序整体操作次数更少，因此，在简单排序中，插入排序效率最高；

时间复杂度（平均）：O（N^2）
时间复杂度（最坏）：O（N^2) 全部都需要交换
时间复杂度（最好）：O（N）全部都不需要交换
空间复杂度： O（1）
稳定性：稳定
```





![插入排序](../../static/images/插入排序.gif)

