# JavaScript实现单向链表

> 链表和数组一样，可以用于**存储一系列的元素**，但是链表和数组的**实现机制完全不同**。链表的每个元素由一个存储**元素本身的节点**和一个**指向下一个元素的引用**（有的语言称为指针或连接）组成。类似于火车头，一节车厢载着乘客（数据），通过节点连接另一节车厢。
>
> 
>
> - head属性指向链表的第一个节点；
> - 链表中的最后一个节点指向null；
> - 当链表中一个节点也没有的时候，head直接指向null；

<img src="images/链表图解.png" alt="链表图解" style="zoom:33%;" />

**数组存在的缺点：**

- 数组的创建通常需要申请一段**连续的内存空间**（一整块内存），并且大小是固定的。所以当原数组**不能满足容量需求**时，需要**扩容**（一般情况下是申请一个更大的数组，比如2倍，然后将原数组中的元素复制过去）。
- 在数组的开头或中间位置插入数据的成本很高，需要进行大量元素的位移。

**链表的优势：**

- 链表中的元素在内存中**不必是连续的空间**，可以充分利用计算机的内存，实现灵活的**内存动态管理**。
- 链表不必在创建时就**确定大小**，并且大小可以**无限地延伸**下去。
- 链表在**插入和删除**数据时，**时间复杂度**可以达到O(1)，相对数组效率高很多。

**链表的缺点：**

- 链表访问任何一个位置的元素时，都需要**从头开始访问**（无法跳过第一个元素访问任何一个元素）。
- 无法通过下标值直接访问元素，需要从头开始一个个访问，直到找到对应的元素。
- 虽然可以轻松地到达**下一个节点**，但是回到**前一个节点**是很难的。

**链表中的常见操作：**

- append（element）：向链表尾部添加一个新的项；
- insert（position，element）：向链表的特定位置插入一个新的项；
- get（position）：获取对应位置的元素；
- indexOf（element）：返回元素在链表中的索引。如果链表中没有该元素就返回-1；
- update（position，element）：修改某个位置的元素；
- removeAt（position）：从链表的特定位置移除一项；
- remove（element）：从链表中移除一项；
- isEmpty（）：如果链表中不包含任何元素，返回trun，如果链表长度大于0则返回false；
- size（）：返回链表包含的元素个数，与数组的length属性类似；
- toString（）：由于链表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值；

```js
class LinkList {
    head = null
    length = 0

    // 向链表尾部添加一个新的项；
    append(data) {
      let node = new Node(data)
      // 情况1：只有一个节点时候
      if (this.length === 0) {
        this.head = node
      } else {
        // 情况2:2个节点及以上的时候
        let current = this.head
        while (current.next) {
          current = current.next
        }
        current.next = node
      }
      this.length += 1
    }

    // 向链表的特定位置插入一个新的项
    insert(position, element) {
      // 边界判断 position小于length 并且 position不能是负数
      if (position > this.length || position < 0) throw new Error('position有误')
      let node = new Node(element)
      // 当positon为0的时候
      if (position === 0) {
        node.next = this.head
        this.head = node
      } else {
        let current = this.head
        let index = 0
        let previous = null
        while (position > index++) {
          previous = current // 这里就可以记录到previous，之前想尽办法得到他。。。。
          current = current.next
        }
        previous.next = node
        node.next = current
      }
      this.length += 1
      return true
    }

    // 获取对应位置的元素
    get(position) {
      if (position >= this.length || position < 0) throw new Error('position有误')
      let current = this.head
      let index = 0
      while (position > index++) {
        current = current.next
      }
      return current.data
    }

    // 返回元素在链表中的索引。如果链表中没有该元素就返回-1；
    indexOf(element) {
      let current = this.head
      let index = 0
      while (this.length - 1 > index) {
        if (current.data === element) break
           current = current.next
           index += 1
         }
      if (current.data === element) return index
      if (current.data !== element) return -1
   		}

     // 修改某个位置的元素；
     update(position, element) {
       if (position >= this.length || position < 0) throw new Error('position有误')
       let current = this.head
       while (position-- > 0) {
         current = current.next
       }
       current.data = element
       return true
     }
     	// 从链表的特定位置移除一项；
    	removeAt(position) {
    	  // 边界判断 position小于length 并且 position不能是负数
    	  if (position > this.length || position < 0) throw new Error('position有误')
    	  let current = this.head
    	  if (position === 0) {
    	    this.head = current.next
    	  } else {
    	    let index = 0
    	    let previous = null
    	    while (position > index++) {
    	      previous = current
    	      current = current.next
    	    }
    	    previous.next = current
    	  }
    	  this.length -= 1
    	  return true
    	}

    // 从链表中移除一项；
    remove(element) {
      let current = this.head
      if (current.data === element) {
        this.head = current.next
        return true
      } else {
        let previous = null
        while (this.length-- > 0) {
          previous = current
          current = current.next
          if (current.data === element) {
            previous.next = current.next
            return true
          }
        }
      }
      return false
    }

    // 如果链表中不包含任何元素，返回trun，如果链表长度大于0则返回false；
    isEmpty() {
      return this.length === 0
    }

    // 返回链表包含的元素个数，与数组的length属性类似；
    size() {
      return this.length
    }

    // 由于链表项使用了Node类，就需要重写继承自JavaScript对象默认的toString方法，让其只输出元素的值；
    toString() {
      let str = ''
      let current = this.head
      for (let i = 0; i < this.length; i++) {
        str += current.data + ' '
        current = current.next
      }
      return str
    }
   }

class Node {
  constructor(data, next = null) {
    this.data = data
    next = next
  }
}

let linklist = new LinkList()
linklist.append('abc')
linklist.append('cba')
linklist.append('nba')
console.log(linklist.toString(), 'toString') // abc cba nba
console.log(linklist.insert(0, 'aaa'), 'insert') // true
console.log(linklist.insert(3, 'ddd'), 'insert') // true
console.log(linklist.toString(), 'toString') // aaa abc cba ddd nba
console.log(linklist.get(2), 'get') // cba
console.log(linklist.indexOf('abc'), 'indexOf') //  1
console.log(linklist.update(0, 'ddd'), 'update') // true
console.log(linklist.toString(), 'toString') // ddd abc cba ddd nba
console.log(linklist.removeAt(0), 'removeAt') // true
console.log(linklist.remove('cba'), 'remove') // true
console.log(linklist.toString(), 'toString') // abc ddd nba
console.log(linklist.size(), 'size') // 3
console.log(linklist.isEmpty(), 'isEmpty') // false
console.log(linklist)
```



## 练习题目



### [61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)

#### 题目描述

```
给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。

示例 1：
输入：head = [1,2,3,4,5], k = 2
输出：[4,5,1,2,3]

示例 2：
输入：head = [0,1,2], k = 4
输出：[2,0,1]

提示：
链表中节点的数目在范围 [0, 500] 内
-100 <= Node.val <= 100
0 <= k <= 2 * 109
```

#### 题解1

这里需要理解 快慢指针的概念。

1. 快指针与慢指针都以每步一个节点的速度向后遍历
2. 快指针比慢指针先走 k 步
3. 当快指针到达终点时，慢指针正好是倒数第 k 个节点



```js
/**
 * @param {ListNode} head
 * @param {number} k
 * @return {ListNode}
 */
var rotateRight = function(head, k) {
  if (!head || !head.next) return head
  // 使用快慢指针
  let fast = head,
    slow = head,
    countLink = head,
    count = 0
  while (countLink) {
    countLink = countLink.next
    count += 1
  }
  // 当出现大于链表的长度的时候应该从0开始
  k = k % count
  while (fast.next) {
    if (k-- <= 0) {
      slow = slow.next
    }
    fast = fast.next
  }
  fast.next = head // 头尾相连
  let res = slow.next // 链表头部
  slow.next = null // 最后的元素进行断开
  return res
}

执行用时：84 ms, 在所有 JavaScript 提交中击败了63.28%的用户
内存消耗：39.6 MB, 在所有 JavaScript 提交中击败了29.85%的用户
```



### [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

#### 题目描述

```
给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。


示例 1：
输入：head = [1,2,3,4]
输出：[2,1,4,3]

示例 2：
输入：head = []
输出：[]

示例 3：
输入：head = [1]
输出：[1]
 

提示：
链表中节点的数目在范围 [0, 100] 内
0 <= Node.val <= 100
```

#### 题解1

使用curent记录当前遍历的位置，

新建一个假的节点去记录上一个位置，先放在链表首。

然后在while中进行替换，替换完之后，需要更新current中的值，这样就可以跳过2个了

```js
var swapPairs = function(head) {
  if (!head || !head.next) return head
  let current = head
  let res = head.next
  
  // 记录上一个节点，为了更加方便后续的交换操作，为了不想重新创建链表，将head赋值过去
  // let preNode = head
  
  // 构造一个节点出来，为了更加方便后续的交换操作
  let preNode = new Node()
  preNode.next = head

  while (current && current.next) {
    let nextNode = current.next
    let nnNode = nextNode.next

    // 将 current 和 下一个的向进行交换位置
    current.next = nnNode // 将 current下一项的指针指向下下项
    nextNode.next = current // 将 nextNode 的下一项指针指向 current

  	// preNode总是记录上一项的的位置，让这个链表产生联系
    preNode.next = nextNode 
    // 需要将最新的current赋值给preNode
    preNode = current 

    // 需要将循环进行跳过2个
    current = nnNode
  }
  return res
}

时间复杂度：所有节点只遍历一遍，时间复杂度为O(N)
空间复杂度：未使用额外的空间，空间复杂度O(1)
```



