# 数组

数组是一种使用最为广泛的数据结构，尤其是在大家的日常开发中，原因无非就是**操作简单**和**支持随机访问**。而字符串大家也可以将其看成是一个字符数组，这更加夯实了数组的重要性。

数组和链表是重要的数据结构，虽然数据结构有很多，比如树，图，哈希表等。但真正的实现还需要落实到具体的基础数据结构，即**数组和链表**。之所以说他们是基础的数据结构，是因为它们直接控制物理内存的使用。

数组使用连续的内存空间，来存储一系列同一数据类型的值。如图表示的是数组的**每一项都使用一个 byte 存储**的情况。

<img src="images/数组内存存储.png" alt="image-20210909140717973" style="zoom:30%;" />



我们知道JavaScript中数组元素可以存储任意元素，但是有些其他语言「强类型语言」不能储存任意类型的数据。

JavaScript是通过堆栈这种内存设计模式处理的，比如基础数据放在栈中，复杂的数据类型放在堆中，但是把指针放在栈中，这样存在数组中的元素都是基础类型，并且遇见复杂的数据项会根据指针找到堆中数据。

而强类型语言是通过定义数据类型这种方式处理。

但是无论哪种处理方式，它们的目的都是为了让数据可以**随意访问**，因为数组的存储是连续的，而且大小固定。

那么当访问某个元素的时候就可以通过访问**基址 + 偏移量**，实现随意访问。

二维数组的表达方式 `board` 或者 `matrix`

### 数组的常见操作

1.随机访问，时间复杂度为O(1)
2.遍历，时间复杂度为O(N)
3.删除、插入元素比较复杂
- 当删除/插入某个元素的时候是需要找到元素，然后进行删除，而且还需要平移操作，所以最坏的是O(N)，最好是O(1)。



## 数组排序

##### **9.排序**

摘自 https://gitee.com/webfrontup/javascript-algorithms

![复杂度曲线图](https://gitee.com/webfrontup/javascript-algorithms/raw/master/assets/big-o-graph.png)

> 你在面试或者日常工作中编写代码的时候，要努力将代码的时间复杂度维持在 O(nlogn) 以下，要知道凡是超过 n 平方的时间复杂度都是难以接受的
>
> 时间复杂度：如上图，嵌套是 n 平方
>
> 空间复杂度：空间复杂度比较容易理解，就是对一个算法在运行过程中临时占用存储空间大小的度量。有的算法需要占用的临时工作单元数与解决问题的规模有关，如果规模越大，则占的存储单元越多。比如，归并排序和快速排序的空间复杂度就是不太一样的

```js
各种排序的 JS 实现
数据结构算法中排序有很多种，常见的、不常见的，至少包含十种以上。根据它们的特性，可以大致分为两种类型：比较类排序和非比较类排序。

比较类排序：通过比较来决定元素间的相对次序，其时间复杂度不能突破 O(nlogn)，因此也称为非线性时间比较类排序。

非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。
																								｜---- 冒泡排序
															｜---- 交换排序--- ｜---- 快速排序
															｜---- 插入排序
																								｜---- 普通选择排序
															｜---- 选择排序    ｜---- 堆排序
						｜---- 比较类排序  ｜---- 归并排序
排序算法 ----｜
						｜----- 非比较类排序｜---- 计数排序
														   ｜---- 桶排序
														   ｜---- 基数排序
														   
稳定：排完序后的数组相同元素不应该互换了位置，本质上这个顺序是不应该换的，如果换了就不稳定了。														   
1.冒泡排序 两层循环，大小不一致时交换位置。时间复杂度 O(n平方) 空间复杂度 O(1) 稳定

2.快速排序 时间复杂度 O(nlogn) O(nlogn) 不稳定

var a = [1, 3, 6, 3, 23, 76, 1, 34, 222, 6, 456, 221];
function quickSort(array) {
  var quick = function(arr) {
    if (arr.length <= 1) return arr
    const len = arr.length
    const index = Math.floor(len >> 1) // 总是找到中间位置
    const pivot = arr.splice(index, 1)[0]
    const left = []
    const right = []
    for (let i = 0; i < len; i++) {
      if (arr[i] > pivot) {
        right.push(arr[i])
      } else if (arr[i] <= pivot) {
        left.push(arr[i])
      }
    }
    return quick(left).concat([pivot], quick(right))
  }
  const result = quick(array)
  return result
}
quickSort(a);//  [1, 1, 3, 3, 6, 6, 23, 34, 76, 221, 222, 456]
最主要的思路是从数列中挑出一个元素，称为 “基准”（pivot）；然后重新排序数列，所有元素比基准值小的摆放在基准前面、比基准值大的摆在基准的后面；在这个区分搞定之后，该基准就处于数列的中间位置；然后把小于基准值元素的子数列（left）和大于基准值元素的子数列（right）递归地调用 quick 方法排序完成，这就是快排的思路

3.插入排序 时间复杂度O(n平方) 空间复杂度 O(1) 稳定
var a = [7, 5, 3, 4, 23];
 function insertSort(array) {
   let current;
   let preveIndex;
   for (let i = 0; i < array.length; i++) {
     current = array[i];
     preveIndex = i - 1;
     while (i > 0 && array[preveIndex] > current) {
       array[preveIndex + 1] = array[preveIndex];
       preveIndex--;
     }
     array[preveIndex + 1] = current;
   }
   return array;
 }
 console.log(insertSort(a));

从执行的结果中可以发现，通过插入排序这种方式实现了排序效果。插入排序的思路是基于数组本身进行调整的，首先循环遍历从 i 等于 1 开始，拿到当前的 current 的值，去和前面的值比较，如果前面的大于当前的值，就把前面的值和当前的那个值进行交换，通过这样不断循环达到了排序的目的。

4.选择排序 时间复杂度 O(n平方) 空间复杂度 O(1) 不稳定
首先将最小的元素存放在序列的起始位置，再从剩余未排序元素中继续寻找最小元素，然后放到已排序的序列后面……以此类推，直到所有元素均排序完毕。
	var a = [7, 5, 3, 4, 23];
	function selectSort(array) {
	  const len = array.length
	  let temp
	  let minIndex
	  for (let i = 0; i < len - 1; i++) {
	    minIndex = i
	    for (let j = i + 1; j < len; j++) {
	      if (array[j] <= array[minIndex]) {
	        minIndex = j
	      }
	    }
	    temp = array[i]
	    array[i] = array[minIndex]
	    array[minIndex] = temp
	  }
	  return array
	}
	selectSort(a);

5.归并排序 时间复杂度 O(nlogn) 空间复杂度 O(n) 稳定
归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。
归并排序是一种稳定的排序方法，和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好得多，因为始终都是 O(nlogn) 的时间复杂度。而代价是需要额外的内存空间
var a = [7, 5, 3, 4, 23];
function mergeSort(array) {
  const merge = (right, left) => {
    const result = []
    let il = 0
    let ir = 0
    while (il < left.length && ir < right.length) {
      if (left[il] < right[ir]) {
        result.push(left[il++])
      } else {
        result.push(right[ir++])
      }
    }
    while (il < left.length) {
      result.push(left[il++])
    }
    while (ir < right.length) {
      result.push(right[ir++])
    }
    return result
  }
  const mergeSort = array => {
    if (array.length === 1) { return array }
    const mid = Math.floor(array.length / 2)
    const left = array.slice(0, mid)
    const right = array.slice(mid, array.length)
    return merge(mergeSort(left), mergeSort(right))
  }
  return mergeSort(array)
}

6.堆排序 时间复杂度 O(nlogn) 空间复杂度 O(1) 不稳定
堆排序是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质，即子结点的键值或索引总是小于（或者大于）它的父节点。堆的底层实际上就是一棵完全二叉树，可以用数组实现。

根节点最大的堆叫作大根堆，根节点最小的堆叫作小根堆，你可以根据从大到小排序或者从小到大来排序，分别建立对应的堆就可以。
var a = [7, 5, 3, 4, 23];
function heap_sort(arr) {
  var len = arr.length
  var k = 0
  function swap(i, j) {
    var temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
  }
  function max_heapify(start, end) {
    var dad = start
    var son = dad * 2 + 1
    if (son >= end) return
    if (son + 1 < end && arr[son] < arr[son + 1]) {
      son++
    }
    if (arr[dad] <= arr[son]) {
      swap(dad, son)
      max_heapify(son, end)
    }
  }
  for (var i = Math.floor(len / 2) - 1; i >= 0; i--) {
    max_heapify(i, len)
  }
   
  for (var j = len - 1; j > k; j--) {
    swap(0, j)
    max_heapify(0, j)
  }
  
  return arr
}
heap_sort(a);

从代码来看，堆排序相比上面几种排序整体上会复杂一些，不太容易理解。不过你应该知道两点：一是堆排序最核心的点就在于排序前先建堆；二是由于堆其实就是完全二叉树，如果父节点的序号为 n，那么叶子节点的索引就分别是 2n+1 和 2n+2。
你理解了这两点，再看代码就比较好理解了。堆排序最后有两个循环：第一个是处理父节点的顺序；第二个循环则是根据父节点和叶子节点的大小对比，进行堆的调整。通过这两轮循环的调整，最后堆排序完成。
完全二叉树：从根往下数，除了最下层外都是全满（都有两个子节点），而最下层所有叶结点都向左边靠拢填满。构造一颗完全二叉树就是【从上到下，从左往右】的放置节点。
满二叉树：二叉树除了叶结点外所有节点都有两个子节点。对于满二叉树而言，叶子的个数等于内部结点（非叶结点）+1，写作 L = l + 1
```

##### sort 方法的底层实现

相信你对 JS 数组的 sort 方法已经不陌生了，上面我也对它的用法进行了详细的介绍。那么它的内部是如何实现的呢？如果你能够进入它的内部看一看源码，理解背后的设计，这对编程思维的提升是一个很好的帮助。

sort 方法在 V8 内部相较于其他方法而言是一个比较难的算法，对于很多边界情况结合排序算法做了反复的优化，但是这里我不会直接拿源码来讲，而是会根据源码的思路，循序善诱地带你实现一个跟引擎性能类似的排序算法，并且一步步拆解其中的奥秘。

这里你需要回顾上一讲说的插入排序和快速排序，接下来我们就对 sort 源码进行分析。

**底层 sort 源码分析**
先大概来梳理一下源码中排序的思路（下面的源码均来自 V8 源码中关于 sort 排序的摘要，地址：V8 源码 sort 排序部分）。

通过研究源码我们先直接看一下结论，如果要排序的元素个数是 n 的时候，那么就会有以下几种情况：

当 n<=10 时，采用插入排序；

当 n>10 时，采用三路快速排序；

10<n <=1000，采用中位数作为哨兵元素；

n>1000，每隔 200~215 个元素挑出一个元素，放到一个新数组中，然后对它排序，找到中间位置的数，以此作为中位数。

在得出这个结论之前，我觉得有必要让你了解为什么这么做。下面就一起来思考两个问题。

1. **为什么元素个数少的时候要采用插入排序？**

虽然插入排序理论上是平均时间复杂度为 O(n^2) 的算法，快速排序是一个平均 O(nlogn) 级别的算法。但是别忘了，这只是理论上平均的时间复杂度估算，但是它们也有最好的时间复杂度情况，而插入排序在最好的情况下时间复杂度是 O(n)。

在实际情况中两者的算法复杂度前面都会有一个系数，当 n 足够小的时候，快速排序 nlogn 的优势会越来越小。倘若插入排序的 n 足够小，那么就会超过快排。而事实上正是如此，插入排序经过优化以后，对于小数据集的排序会有非常优越的性能，很多时候甚至会超过快排。因此，对于很小的数据量，应用插入排序是一个非常不错的选择。

2. **为什么要花这么大的力气选择哨兵元素？**

因为快速排序的性能瓶颈在于递归的深度，最坏的情况是每次的哨兵都是最小元素或者最大元素，那么进行 partition（一边是小于哨兵的元素，另一边是大于哨兵的元素）时，就会有一边是空的。如果这么排下去，递归的层数就达到了 n , 而每一层的复杂度是 O(n)，因此快排这时候会退化成 O(n^2) 级别。

这种情况是要尽力避免的，那么如何来避免？就是让哨兵元素尽可能地处于数组的中间位置，让最大或者最小的情况尽可能少。这时候，你就能理解 V8 里面所做的各种优化了。

接下来，我们看一下官方实现的 sort 排序算法的代码基本结构。

```js
function ArraySort(comparefn) {
	  CHECK_OBJECT_COERCIBLE(this,"Array.prototype.sort");
	  var array = TO_OBJECT(this);
	  var length = TO_LENGTH(array.length);
	  return InnerArraySort(array, length, comparefn);
}
function InnerArraySort(array, length, comparefn) {
  // 比较函数未传入
  if (!IS_CALLABLE(comparefn)) {
	    comparefn = function (x, y) {
	      if (x === y) return 0;
	      if (%_IsSmi(x) && %_IsSmi(y)) {
	        return %SmiLexicographicCompare(x, y);
	      }
	      x = TO_STRING(x);
	      y = TO_STRING(y);
	      if (x == y) return 0;
	      else return x < y ? -1 : 1;
	 };
  }
  function InsertionSort(a, from, to) {
    // 插入排序
    for (var i = from + 1; i < to; i++) {
	      var element = a[i];
	      for (var j = i - 1; j >= from; j--) {
	        var tmp = a[j];
	        var order = comparefn(tmp, element);
	        if (order > 0) {
	          a[j + 1] = tmp;
	        } else {
	          break;
	        }
	      }
	    a[j + 1] = element;
	 }
  }
  function GetThirdIndex(a, from, to) {   // 元素个数大于1000时寻找哨兵元素
    var t_array = new InternalArray();
	var increment = 200 + ((to - from) & 15);
	var j = 0;
	from += 1;
	to -= 1;
	for (var i = from; i < to; i += increment) {
	   t_array[j] = [i, a[i]];
	   j++;
	}
	t_array.sort(function(a, b) {
	   return comparefn(a[1], b[1]);
	});
	var third_index = t_array[t_array.length >> 1][0];
	return third_index;
  }
  function QuickSort(a, from, to) {  // 快速排序实现
        //哨兵位置
	    var third_index = 0;
	    while (true) {
	      if (to - from <= 10) {
	        InsertionSort(a, from, to); // 数据量小，使用插入排序，速度较快
	        return;
	      }
	      if (to - from > 1000) {
	        third_index = GetThirdIndex(a, from, to);
	      } else {
            // 小于1000 直接取中点
	        third_index = from + ((to - from) >> 1);
	      }
          // 下面开始快排
	      var v0 = a[from];
	      var v1 = a[to - 1];
	      var v2 = a[third_index];
	      var c01 = comparefn(v0, v1);
	      if (c01 > 0) {
	        var tmp = v0;
	        v0 = v1;
	        v1 = tmp;
	      }
	      var c02 = comparefn(v0, v2);
	      if (c02 >= 0) {
	        var tmp = v0;
	        v0 = v2;
	        v2 = v1;
	        v1 = tmp;
	      } else {
	        var c12 = comparefn(v1, v2);
	        if (c12 > 0) {
	          var tmp = v1;
	          v1 = v2;
	          v2 = tmp;
	        }
	      }
	      a[from] = v0;
	      a[to - 1] = v2;
	      var pivot = v1;
	      var low_end = from + 1; 
	      var high_start = to - 1;
	      a[third_index] = a[low_end];
	      a[low_end] = pivot;
	      partition: for (var i = low_end + 1; i < high_start; i++) {
	        var element = a[i];
	        var order = comparefn(element, pivot);
	        if (order < 0) {
	          a[i] = a[low_end];
	          a[low_end] = element;
	          low_end++;
	        } else if (order > 0) {
	          do {
	            high_start--;
	            if (high_start == i) break partition;
	            var top_elem = a[high_start];
	            order = comparefn(top_elem, pivot);
	          } while (order > 0);
	          a[i] = a[high_start];
	          a[high_start] = element;
	          if (order < 0) {
	            element = a[i];
	            a[i] = a[low_end];
	            a[low_end] = element;
	            low_end++;
	          }
	        }
	      }
          // 快排的核心思路，递归调用快速排序方法
	      if (to - high_start < low_end - from) {
	        QuickSort(a, high_start, to);
	        to = low_end;
	      } else {
	        QuickSort(a, from, low_end);
	        from = high_start;
	      }
	  }
  }
```


从上面的源码分析来看，当数据量小于 10 的时候用插入排序；当数据量大于 10 之后采用三路快排；当数据量为 10~1000 时候直接采用中位数为哨兵元素；当数据量大于 1000 的时候就开始寻找哨兵元素。

我们直接从上面的源码中就可以看到整个 sort 源码的编写逻辑，也就是上面总结分析的逻辑对应实现。如果你还是没有理解得很好，我建议你再重新看一下插入排序和快速排序的核心逻辑。其实关键点在于根据数据量的大小，从而确定用什么排序来解决；时间复杂度是根据数据量的大小，从而进行变化的，这一点需要深入理解。

总结
那么关于 sort 排序方法我就介绍到这里了。这一讲，我把 JS 中的 sort 方法详细讲解了一遍，同时又带你剖析了 sort 方法中内部的原理实现，你需要好好学习排序相关的算法，才能真正理解 V8 源码中实现的排序逻辑。

此外，关于排序时间复杂度也不用死记硬背，在不同的数据量情况下，不代表某种排序一定就要比另外一种排序速度快，这点你要牢记，然后根据不同的场景进行不同的分析。

那么讲到这里，我们再来整理一下快速排序和插入排序的最好以及最快情况下的时间复杂度的对比，请看下面的表格。

**reduce 方法的底层实现**

 [ecma reduce介绍](https://tc39.es/ecma262/#sec-array.prototype.reduce)

```js
When the reduce method is called with one or two arguments, the following steps are taken:
1. Let O be ? ToObject(this value).
2. Let len be ? LengthOfArrayLike(O).
3. If IsCallable(callbackfn) is false, throw a TypeError exception.
4. If len = 0 and initialValue is not present, throw a TypeError exception.
5. Let k be 0.
6. Let accumulator be undefined.
7. If initialValue is present, then
    Set accumulator to initialValue.
8. Else,
    Let kPresent be false.
    Repeat, while kPresent is false and k < len,
        Let Pk be ! ToString(F(k)).
        Set kPresent to ? HasProperty(O, Pk).
        If kPresent is true, then
        Set accumulator to ? Get(O, Pk).
        Set k to k + 1.
    If kPresent is false, throw a TypeError exception.
9. Repeat, while k < len,
    Let Pk be ! ToString(F(k)).
    Let kPresent be ? HasProperty(O, Pk).
    If kPresent is true, then
        Let kValue be ? Get(O, Pk).
        Set accumulator to ? Call(callbackfn, undefined, « accumulator, kValue, F(k), O »).
    Set k to k + 1.
10. Return accumulator.


Array.prototype.reduce  = function(callbackfn, initialValue) {
  // 异常处理，和 map 类似
  if (this === null || this === undefined) {
    throw new TypeError("Cannot read property 'reduce' of null");
  }
  // 处理回调类型异常
  if (Object.prototype.toString.call(callbackfn) != "[object Function]") {
    throw new TypeError(callbackfn + ' is not a function')
  }
  let O = Object(this);
  let len = O.length >>> 0;
  let k = 0;
  let accumulator = initialValue;  // reduce方法第二个参数作为累加器的初始值
  if (accumulator === undefined) {  // 初始值不传的处理
    for(; k < len ; k++) {
      if (k in O) {
        accumulator = O[k];
        k++;
        break;
      }
    }
    throw new Error('Each element of the array is empty');
  }
  for(;k < len; k++) {
    if (k in O) {
      // 注意 reduce 的核心累加器
      accumulator = callbackfn.call(undefined, accumulator, O[k], O);
    }
  }
  return accumulator;
}
```





## 数组题目练习

### [第三大的数](https://leetcode-cn.com/problems/third-maximum-number)

#### 题目描述

```
示例 1：
输入：[3, 2, 1]
输出：1
解释：第三大的数是 1 。

示例 2：
输入：[1, 2]
输出：2
解释：第三大的数不存在, 所以返回最大的数 2 。

示例 3：
输入：[2, 2, 3, 1]
输出：1
解释：注意，要求返回第三大的数，是指在所有不同数字中排第三大的数。
此例中存在两个值为 2 的数，它们都排第二。在所有不同数字中排第三大的数为 1 。
```

#### 题解

##### 解法1

现将数组从大到小排序，并进行去重，接着就可以按照题目取值。

<details>   
  <summary>点击展开</summary>   
 <pre><blockcode>
var thirdMax = function(nums) {
let newArr = nums.sort((a, b) => b-a)
	newArr = Array.from(new Set(newArr))
	if (newArr.length >= 3) {
	  return newArr[2]
	} else {
	  return newArr[0]
	}
};
</blockcode></pre>
 <pre><blockcode>
执行用时：80 ms, 在所有 JavaScript 提交中击败了 59.84% 的用户
内存消耗：39.6 MB, 在所有 JavaScript 提交中击败了 36.35% 的用户
通过测试用例：30 / 30
</blockcode></pre>
</details>  

##### 解法2

 定义第一大的数字 第二大的数字，第三大的数字，接着遍历数组，进行赋值，需要注意重复数字，最后按照题目取值。

<details>   
  <summary>点击展开</summary>   
 <pre><blockcode>
var thirdMax = function(nums) {
  let first = -Infinity // 最大
  let second = -Infinity // 第二大
  let third = -Infinity // 最三大
  for (let i = 0; i < nums.length; i++) {
    const e = nums[i]
    if (e > first) [first, second, third] = [e, first, second]
    else if (e > second && e !== first) [second, third] = [e, second]
    else if (e > third && e !== second && e !== first) third = e
  }
  console.log(first, second, third)
  return third !== -Infinity ? third : first
}
</blockcode></pre>
 <pre><blockcode>
执行用时：68 ms, 在所有 JavaScript 提交中击败了 92.56% 的用户
内存消耗：40 MB, 在所有 JavaScript 提交中击败了 12.50% 的用户
通过测试用例：30 / 30
</blockcode></pre>
</details>  

##### 解法3

先数组排序，然后用一个变量标记第三大的值，然后返回。

<details>   
  <summary>点击展开</summary>   
 <pre><blockcode>
var thirdMax = function(nums) {
    let newArr = nums.sort((a, b) => b - a)
    let third = 0
    for (let i = 0; i < newArr.length; i++) {
      if (newArr[i] > newArr[i + 1]) third++
      if (third === 2) return newArr[i + 1]
    }
    return newArr[0]
}
</blockcode></pre>
 <pre><blockcode>
执行用时：68 ms, 在所有 JavaScript 提交中击败了91.87%的用户
内存消耗：39.1 MB, 在所有 JavaScript 提交中击败了85.54%的用户
</blockcode></pre>
</details>   





### [剑指 Offer 53 - II. 0 ～ n-1 中缺失的数字](https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/)

#### 题目描述

```js
一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。

示例 1:
输入: [0,1,3]
输出: 2

示例 2:
输入: [0,1,2,3,4,5,6,7,9]
输出: 8
```

#### 题解

##### 解法1

遍历数组将当前项和下一项进行对比，然后按照边界取值

<details>   
  <summary>点击展开</summary>   
 <pre><blockcode>
var missingNumber = function(nums) {
  if(nums[0] > 0) return 0
      for (let i = 0; i < nums.length; i++) {
        const e = nums[i]
        if (e + 1 !== nums[i + 1]  ) return nums.length >= i + 1 ?  e + 1:e
      }
}
</blockcode></pre>
 <pre><blockcode>
执行用时：76 ms, 在所有 JavaScript 提交中击败了 58.82% 的用户
内存消耗：40.3 MB, 在所有 JavaScript 提交中击败了27.90%的用户
通过测试用例：122 / 122
</blockcode></pre> 
</details>   

##### 解法2

使用二分法，不断缩少查询范围。

<details>   
  <summary>点击展开</summary>   
 <pre><blockcode>
var missingNumber = function(nums) {
  let left = 0,
    right = nums.length - 1
  // [left,right] 的集合
  while (left <= right) {
    let mid = parseInt((left + right) / 2)
    console.log(mid, 'mid')
    // 左边是符合标准的
    if (nums[mid] === mid) {
      left = mid + 1 // 得出 [mid+1,right]
    }
    // 左边是不符合标准
    else {
      right = mid - 1 // 得出[left,mid - 1 ]
      console.log(right, 'right')
    }
  }
  return left
}
</blockcode></pre>
 <pre><blockcode>
执行用时：64 ms, 在所有 JavaScript 提交中击败了94.09%的用户
内存消耗：39.6 MB, 在所有 JavaScript 提交中击败了98.49%的用户
</blockcode></pre>
</details>   



### [989. 数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer)

#### 题目描述

```
对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。
给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。

示例 1：

输入：A = [1,2,0,0], K = 34
输出：[1,2,3,4]
解释：1200 + 34 = 1234
示例 2：

输入：A = [2,7,4], K = 181
输出：[4,5,5]
解释：274 + 181 = 455
示例 3：

输入：A = [2,1,5], K = 806
输出：[1,0,2,1]
解释：215 + 806 = 1021
示例 4：

输入：A = [1, 2, 6, 3, 0, 7, 1, 7, 1, 9, 7, 5, 6, 6, 4, 4, 0, 0, 6, 3], K = 516
输出：[1,2,6,3,0,7,1,7,1,9,7,5,6,6,4,4,0,5,7,9]
解释：12...0063 + 516 = 12...0579

提示：

1 <= A.length <= 10000
0 <= A[i] <= 9
0 <= K <= 10000
如果 A.length > 1，那么 A[0] != 0
```

#### 题解

##### 题解1

第一步先将K加进A里面，按照个十百的位置加，第二步将A里面的数字判断大于9的需要进位，需要在最后面开始遍历。

<details>   
  <summary>点击展开</summary>   
 <pre><blockcode>
var addToArrayForm = function(num, k) {
  // 第一步先将k 加进num里，
  let kArr = ('' + k).split('').reverse()
  let len = kArr.length
  for (let i = 0; i < len; i++) {
    if (num[num.length - 1 - i] !== undefined) num[num.length - 1 - i] += +kArr[i]
    else num.unshift(kArr[i])
  }
  console.log(num, 'num')
  // 第二步将num里把每一项进行进位
  let i = num.length - 1
  while (i >= 0) {
    // 大于9 进一
    if (num[i] > 9) {
      debugger
      console.log(i, 'i')
      if (i > 0) num[i - 1] = +num[i - 1] + parseInt((num[i] % 100) / 10)
      else {
        console.log(num[i], 'um[i]')
        if (num[i] > 9) {
          num.unshift()
          let first = parseInt(num[i] % 10)
          let second = parseInt((num[i] % 100) / 10)
          num[i] = first
          num.unshift(second)
        } else {
          num.unshift(num[i])
        }
      }
      num[i] = parseInt(num[i] % 10)
    }
    i--
  }
  return num
}
</blockcode></pre>
 <pre><blockcode>
执行用时：200 ms, 在所有 JavaScript 提交中击败了 21.32%的用户
内存消耗：46.4 MB, 在所有 JavaScript 提交中击败了9.65%的用户
通过测试用例：156 / 156
 </blockcode></pre>
</details>  

##### 题解2

思路同上，不过对进位做了更多的优化和技巧

<details>   
  <summary>点击展开</summary>   
 <pre><blockcode>
var addToArrayForm = function(num, k) {
  let len = k.toString().length
  // 先让每个位置对应加起来
  for (let i = 0; i < len; i++) {
    // 先补全num数组
    if (num.length < len) num.unshift(0)
    num[num.length - 1 - i] += k % 10
    k = parseInt(k / 10)
  }
  // console.log(num, 'num')
  // 判断对应位是否存在 >9的情况
  // debugger
  for (let i = 0; i < num.length; i++) {
    if (num[0] > 9) num.unshift(0) // 当边界存在 >9需要特殊处理
    let e = num[num.length - 1 - i]
    if (e > 9) {
      num[num.length - 2 - i] += parseInt((e / 10) % 10)
      num[num.length - 1 - i] = e % 10
    }
  }
  return num
}
</blockcode></pre>
 <pre><blockcode>
执行用时：120 ms, 在所有 JavaScript 提交中击败了69.04%的用户
内存消耗：42.4 MB, 在所有 JavaScript 提交中击败了83.25%的用户
通过测试用例：156 / 156
</blockcode></pre>
</details>   

##### 题解3

先将数组反转，然后循环往里面加，长度为较长的num/k，记录进位，将个位和原来数字，如果还有进位，相加，得出新的项，在得出新的进位。

<details>   
  <summary>点击展开</summary>   
 <pre><blockcode>
var addToArrayForm = function(num, k) {
  const result = []
  num.reverse()
  let karr = String(k)
    .split('')
    .reverse()
  let carry = 0
  for (let i = 0; i < Math.max(num.length, karr.length); i++) {
    let count = Number(num[i] || 0) + Number(karr[i] || 0) + carry
    result.push(count % 10)
    carry = Math.floor(count / 10)
  }
  if (carry) result.push(carry)
  return result.reverse()
}
</blockcode></pre>
 <pre><blockcode>
执行用时：132 ms, 在所有 JavaScript 提交中击败了62.44%的用户
内存消耗：44.3 MB, 在所有 JavaScript 提交中击败了33.00%的用户
</blockcode></pre>
</details>   



### [821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)

#### 题目描述

```
给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。

返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。

两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。

示例 1：

输入：s = "loveleetcode", c = "e"
输出：[3,2,1,0,1,0,0,1,2,2,1,0]
解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。
距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。
距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。
对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。
距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。
示例 2：

输入：s = "aaab", c = "b"
输出：[3,2,1,0]
 

提示：
1 <= s.length <= 104
s[i] 和 c 均为小写英文字母
题目数据保证 c 在 s 中至少出现一次
```

#### 题解

##### 题解1

第一次循环得出数组，将找不到的存入 Infinity，这样得出一个初始的数组

第二次循环将得到值后进行和第一次的值判断，最后得出最终的数组

<details>   
  <summary>点击展开</summary>   
 <pre><blockcode>
var shortestToChar = function(s, c) {
  let result = []
  let sArr = s.split('')
  // 这是左循环
  for (let i = 0; i < sArr.length; i++) {
    let distance = 0
    while (true) {
      if (sArr[i + distance] === c) break
      distance++
      if (distance > s.length) {
        distance = Infinity
        break
      }
    }
    result.push(distance)
  }
  console.log(result, 'result')
  // 这是右循环
  for (let i = sArr.length - 1; i >= 0; i--) {
    let distance = 0
    while (true) {
      if (sArr[i - distance] === c) break
      distance++
      if (distance > s.length) break
    }
    // 如果小于则替换
    if (distance < result[i]) result.splice(i, 1, distance)
  }
  return result
}
</blockcode></pre>
 <pre><blockcode>
执行用时：104 ms, 在所有 JavaScript 提交中击败了20.69%的用户
内存消耗：39.3 MB, 在所有 JavaScript 提交中击败了94.83%的用户 空间复杂度为O(N)
</blockcode></pre>
</details>   



### [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

#### 题目描述

```
给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。

请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。

注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。

示例 1：
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
解释：需要合并 [1,2,3] 和 [2,5,6] 。
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。

示例 2：
输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]
解释：需要合并 [1] 和 [] 。
合并结果是 [1] 。

示例 3：
输入：nums1 = [0], m = 0, nums2 = [1], n = 1
输出：[1]
解释：需要合并的数组是 [] 和 [1] 。
合并结果是 [1] 。
注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。
```

#### 题解

##### 题解1：

先去除0，然后合并数组，在排序。

<details>   
  <summary>点击展开</summary>   
 <pre><blockcode>
 var merge = function(nums1, m, nums2, n) {
  nums1.splice(nums1.length - n, n, ...nums2)
  nums1.sort((a, b) => b - a)
  return nums1
}
</blockcode></pre>
 <pre><blockcode>
执行用时：56 ms, 在所有 JavaScript 提交中击败了99.41%的用户
内存消耗：38.1 MB, 在所有 JavaScript 提交中击败了21.81%的用户
时间复杂度 O(N) 空间复杂度 O(N^2),主要是sort中的
</blockcode></pre>
</details>   



### [380. 常数时间插入、删除和获取随机元素](https://leetcode-cn.com/problems/insert-delete-getrandom-o1/)

#### 题目描述

```
实现RandomizedSet 类：

RandomizedSet() 初始化 RandomizedSet 对象
bool insert(int val) 当元素 val 不存在时，向集合中插入该项，并返回 true ；否则，返回 false 。
bool remove(int val) 当元素 val 存在时，从集合中移除该项，并返回 true ；否则，返回 false 。
int getRandom() 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 相同的概率 被返回。
你必须实现类的所有函数，并满足每个函数的 平均 时间复杂度为 O(1) 。

 

示例：

输入
["RandomizedSet", "insert", "remove", "insert", "getRandom", "remove", "insert", "getRandom"]
[[], [1], [2], [2], [], [1], [2], []]
输出
[null, true, false, true, 2, true, false, 2]

解释
RandomizedSet randomizedSet = new RandomizedSet();
randomizedSet.insert(1); // 向集合中插入 1 。返回 true 表示 1 被成功地插入。
randomizedSet.remove(2); // 返回 false ，表示集合中不存在 2 。
randomizedSet.insert(2); // 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。
randomizedSet.getRandom(); // getRandom 应随机返回 1 或 2 。
randomizedSet.remove(1); // 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。
randomizedSet.insert(2); // 2 已在集合中，所以返回 false 。
randomizedSet.getRandom(); // 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。
 

提示：

-231 <= val <= 231 - 1
最多调用 insert、remove 和 getRandom 函数 2 * 105 次
在调用 getRandom 方法时，数据结构中 至少存在一个 元素。
```

#### 题解

##### 题解1 

这题最主要的是 对象和数组建立联系，删除的时候将要删除的元素和最后的元素进行互换位置，还需要注意其他的数据也要换位置

```js
var RandomizedSet = function() {
  // this.set = new Set()
  //存放值
  this.set = []
  //表示数组中的对应的值的下标是多少
  //用哈希表的键(key)存储val 用值(value)存储这个值在数组中的下标index
  //然后删除的时候就可以根据val找到数组里面的下标 然后在数组中进行删除
  //比如说当我想要找数组里面的10 就可以通过setMap[10]来找到数组中对应的下标然后删除 不需要遍历
  this.setMap = {}
}
RandomizedSet.prototype.insert = function(val) {
  //如果已经有这个值了就返回false
  if (typeof this.setMap[val] !== 'undefined') return false
  //在表中记录插入的值在数组中的下标
  this.setMap[val] = this.set.length
  //在数组中添加这个值
  this.set.push(val)
  return true
}

RandomizedSet.prototype.remove = function(val) {
  //如果没有这个值就返回false
  if (typeof this.setMap[val] === 'undefined') return false
  // move the last element to the place idx of the element to delete
  // 得到最后一个数的下标
  let lastIndex = this.set.length - 1
  //得到数组中最后一个数
  let lastNum = this.set[lastIndex]
  // 找到要删除的值的下标
  let deleteIndex = this.setMap[val]
  // 用最后一个数代替要删除的值
  this.set[deleteIndex] = lastNum
  // 在表中把最后一个数的位置设置为要删除的值的位置
  this.setMap[lastNum] = deleteIndex
  // 删除最后一个值
  this.set.pop()
  delete this.setMap[val]
  return true
}

RandomizedSet.prototype.getRandom = function() {
  let size = this.set.length
  //返回一个0到set的长度之间的随机数
  let random = Math.floor(Math.random() * size)
  //以随机数为下标返回
  return this.set[random]
}

执行用时：380 ms, 在所有 JavaScript 提交中击败了75.98%的用户
内存消耗：86 MB, 在所有 JavaScript 提交中击败了46.55%的用户

```



### [41. 缺失的第一个正数](https://leetcode-cn.com/problems/first-missing-positive/)

### [59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/)

### [859. 亲密字符串](https://leetcode-cn.com/problems/buddy-strings/)



参考

[91算法](https://leetcode-solution.cn/)

