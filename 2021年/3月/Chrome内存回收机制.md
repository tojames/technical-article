# 内存回收机制

> - 内存管理流程 
>   1. 分配你所需要的系统内存空间；
>   2. 使用分配到的内存进行读或者写等操作；
>   3. 不需要使用内存时，将其空间释放或者归还。
> - 内存回收机制只针对两种数据类型，`栈` 和`堆`。
> - 栈和堆的处理方式
>   1. 栈内存中的基本类型，可以通过操作系统直接处理。
>   2. 堆内存中的引用类型，正是由于可以经常变化，大小不固定，因此需要 JavaScript 的引擎通过垃圾回收机制来处理。

**注意 由于栈是操作系统处理的，我们无法去探究，本篇探究Chrome 浏览器中JavaScript 的 V8 引擎。**

根据不同的操作系统（操作系统有 64 位和 32 位的）内存大小会不同，大的可以到 1.4G 的空间，小的只能到 0.7G 的空间。设置这么少的原因可能是。早些年由于 Web 应用都比较简单，其实并未考虑占据过多的内存空间；另外又由于被 V8 的垃圾回收机制所限制，比如清理大量的内存时会耗费很多时间，这样会引起 JavaScript 执行的线程被挂起，会影响当前执行的页面应用的性能，这些可能分配这么少的原因。

Chrome 的 JavaScript 引擎 V8 将堆内存分为两类 新生代的回收机制和老生代的回收机制

##### 新生代内存回收

> 新生代的内存回收的空间，在 64 位操作系统下分配为 32MB，正是因为新生代中的变量存活时间短，不太容易产生太大的内存压力，因此不够大也是可以理解的。首先系统会将分配给新生代的内存空间分为两部分 
>
> `form`和 `to`
>
>  `to`是目前闲置的内存空间。当浏览器开始进行内存的垃圾回收时，JavaScript 的 V8 引擎会将`form`的对象检查一遍。如果引擎检测是存活对象，那么会复制到`to`的内存空间去；如果不是存活的对象，则直接进行系统回收。当所有`form`的内存里的对象没有了的时候，等再有新生代的对象产生时，上面的部分`form`和 `to`对调，这样来循环处理。
>
> 如果是顺序放置的那比较好处理，可以按照上面所说的处理方式。但是如果是下图这样零散的场景怎么处理呢？
>
> 通常情况下，由于堆内存是连续分配的，但是也有可能出现分散存放这种内存分配情况，这种零散的分配情况就造成了内存碎片，会影响比较大的内存对象的放置。是通过算法 Scavenge优化，它主要就是解决刚刚那张内存碎片的情况，在通过算法处理过后，内存中对象的排布都会变成有序排列方式。

##### 老生代内存回收

> 